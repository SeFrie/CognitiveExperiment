<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.py" />
              <option name="originalContent" value="import tkinter as tk&#10;from tkinter import ttk&#10;import pandas as pd&#10;import csv&#10;import uuid&#10;import os&#10;import random&#10;from datetime import datetime&#10;from test_screen import TestScreen&#10;from second_test_screen import SecondTestScreen&#10;&#10;class ExperimentApp:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Cognitive Science Experiment&quot;)&#10;        self.root.geometry(&quot;800x600&quot;)&#10;        self.root.configure(bg='white')&#10;&#10;        # Generate unique ID for this session&#10;        self.unique_id = str(uuid.uuid4())[:8]  # Short unique ID&#10;&#10;        # Load word data&#10;        self.word_data = self.load_word_data()&#10;&#10;        # Select random words for both phases&#10;        self.select_random_word_sets()&#10;&#10;        # Show welcome screen&#10;        self.show_welcome_screen()&#10;&#10;    def select_random_word_sets(self):&#10;        &quot;&quot;&quot;Select two sets of 25 random words for the two experiment phases&quot;&quot;&quot;&#10;        total_words = len(self.word_data)&#10;&#10;        if total_words &lt; 50:&#10;            print(f&quot;Warning: Only {total_words} words available. Need at least 50 for two sets of 25.&quot;)&#10;            # If we don't have enough words, use what we have&#10;            all_indices = list(range(total_words))&#10;            random.shuffle(all_indices)&#10;&#10;            mid_point = min(25, total_words // 2)&#10;            self.first_phase_indices = all_indices[:mid_point]&#10;            self.second_phase_indices = all_indices[mid_point:min(mid_point * 2, total_words)]&#10;        else:&#10;            # Randomly select 50 unique indices&#10;            all_indices = list(range(total_words))&#10;            random.shuffle(all_indices)&#10;&#10;            # First 25 for phase 1, next 25 for phase 2&#10;            self.first_phase_indices = sorted(all_indices[:25])&#10;            self.second_phase_indices = sorted(all_indices[25:50])&#10;&#10;        # Create DataFrames for each phase - keep original indices for CSV matching&#10;        # Reset index but keep the original word_id for matching&#10;        self.first_phase_words = self.word_data.iloc[self.first_phase_indices].copy()&#10;        self.first_phase_words.reset_index(drop=True, inplace=True)&#10;&#10;        self.second_phase_words = self.word_data.iloc[self.second_phase_indices].copy()&#10;        self.second_phase_words.reset_index(drop=True, inplace=True)&#10;&#10;        print(f&quot;Phase 1 word indices: {self.first_phase_indices}&quot;)&#10;        print(f&quot;Phase 2 word indices: {self.second_phase_indices}&quot;)&#10;        print(f&quot;Phase 1 first word: {self.first_phase_words.iloc[0]['ice']} -&gt; {self.first_phase_words.iloc[0]['eng']} (word_id: {self.first_phase_words.iloc[0]['word_id']})&quot;)&#10;        print(f&quot;Phase 2 first word: {self.second_phase_words.iloc[0]['ice']} -&gt; {self.second_phase_words.iloc[0]['eng']} (word_id: {self.second_phase_words.iloc[0]['word_id']})&quot;)&#10;&#10;    def load_word_data(self):&#10;        &quot;&quot;&quot;Load word data from Excel file&quot;&quot;&quot;&#10;        try:&#10;            df = pd.read_excel('../word_pairs/Icelandic_English_Danish_words.xlsx')&#10;            print(f&quot;Excel file loaded successfully! Shape: {df.shape}&quot;)&#10;            print(f&quot;Columns: {df.columns.tolist()}&quot;)&#10;&#10;            # Check if the Excel file has the expected columns&#10;            # Try different possible column name variations&#10;            ice_col = None&#10;            eng_col = None&#10;            word_id_col = None&#10;&#10;            # Look for Icelandic column (could be 'ice', 'icelandic', or index-based)&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'ice' in col_str or 'island' in col_str:&#10;                    ice_col = col&#10;                    break&#10;&#10;            # Look for English column (could be 'eng', 'english', or index-based)&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'eng' in col_str or 'english' in col_str:&#10;                    eng_col = col&#10;                    break&#10;&#10;            # Look for word_id column&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'word_id' in col_str or 'id' in col_str:&#10;                    word_id_col = col&#10;                    break&#10;&#10;            # If we can't find named columns, assume columns by position&#10;            if ice_col is None and eng_col is None:&#10;                if len(df.columns) &gt;= 2:&#10;                    # Assume first column is Icelandic, second is English&#10;                    ice_col = df.columns[0]&#10;                    eng_col = df.columns[1]&#10;&#10;            print(f&quot;Using columns - word_id: {word_id_col}, ice: {ice_col}, eng: {eng_col}&quot;)&#10;&#10;            # Create standardized DataFrame&#10;            result_data = []&#10;            for index, row in df.iterrows():&#10;                word_id = row[word_id_col] if word_id_col else index + 1&#10;                ice_word = row[ice_col] if ice_col else ''&#10;                eng_word = row[eng_col] if eng_col else ''&#10;&#10;                result_data.append({&#10;                    'word_id': word_id,&#10;                    'ice': ice_word,&#10;                    'eng': eng_word&#10;                })&#10;&#10;            result_df = pd.DataFrame(result_data)&#10;            print(f&quot;Processed {len(result_df)} word pairs&quot;)&#10;            print(&quot;First few pairs:&quot;)&#10;            for i in range(min(5, len(result_df))):&#10;                row = result_df.iloc[i]&#10;                print(f&quot;  {i+1}: {row['ice']} -&gt; {row['eng']}&quot;)&#10;&#10;            return result_df&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading word data: {e}&quot;)&#10;            # Create dummy data if file doesn't exist or can't be read&#10;            return pd.DataFrame({&#10;                'word_id': [1, 2, 3, 4, 5],&#10;                'ice': ['hestur', 'hundur', 'köttur', 'fugl', 'fiskur'],&#10;                'eng': ['horse', 'dog', 'cat', 'bird', 'fish']&#10;            })&#10;&#10;    def show_welcome_screen(self):&#10;        &quot;&quot;&quot;Display the welcome screen&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Welcome message&#10;        welcome_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Welcome&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        welcome_label.pack(expand=True)&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=20)&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightblue',&#10;            command=self.on_next_clicked,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def on_next_clicked(self):&#10;        &quot;&quot;&quot;Handle next button click - create CSV and show information screen&quot;&quot;&quot;&#10;        self.create_csv_file()&#10;        self.show_information_screen()&#10;&#10;    def create_csv_file(self):&#10;        &quot;&quot;&quot;Create CSV file with unique name and populate with data&quot;&quot;&quot;&#10;        # Create unique filename with timestamp&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        filename = f&quot;../data/experiment_{self.unique_id}_{timestamp}.csv&quot;&#10;&#10;        # Ensure data directory exists&#10;        os.makedirs(&quot;../data&quot;, exist_ok=True)&#10;&#10;        # Prepare data for CSV&#10;        csv_data = []&#10;&#10;        # Add header&#10;        csv_data.append(['id', 'word_id', 'ice', 'eng', 'answ_1', 'answ_2'])&#10;&#10;        # Add data rows&#10;        for index, row in self.word_data.iterrows():&#10;            csv_row = [&#10;                self.unique_id,  # unique id&#10;                int(row.get('word_id', index + 1)),  # word_id from Excel or index&#10;                row.get('ice', ''),  # Icelandic word&#10;                row.get('eng', ''),  # English word&#10;                '',  # answ_1 - empty for now&#10;                ''   # answ_2 - empty for now&#10;            ]&#10;            csv_data.append(csv_row)&#10;&#10;        # Write to CSV file&#10;        try:&#10;            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:&#10;                writer = csv.writer(csvfile)&#10;                writer.writerows(csv_data)&#10;            print(f&quot;CSV file created: {filename}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error creating CSV file: {e}&quot;)&#10;&#10;    def show_information_screen(self):&#10;        &quot;&quot;&quot;Display the information screen with dummy text&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Information&quot;,&#10;            font=(&quot;Arial&quot;, 24, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 20))&#10;&#10;        # Create text frame with scrollbar&#10;        text_frame = tk.Frame(main_frame, bg='white')&#10;        text_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Text widget with scrollbar&#10;        text_widget = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 12),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            padx=10,&#10;            pady=10&#10;        )&#10;&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Pack text widget and scrollbar&#10;        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Dummy text content&#10;        dummy_text = &quot;&quot;&quot;&#10;                Welcome to this cognitive science experiment.&#10;        &#10;        We are very grateful for your participation.&#10;        This experiment consists of several parts, including memorization and recall tasks.&#10;        First you will be presented with a list of word pairs to memorize in 8 minutes.&#10;        After a set period of time, you will be tested for 3 minutes on your memory of these word pairs.&#10;        Then you will watch YouTube short for 8 minutes.&#10;        Finally, you will be tested again on your memory of the word pairs for 3 minutes.&#10;        Your responses will be recorded in a text file for analysis.&#10;        &#10;        If you have any questions, feel free to ask the experimenter before we begin.&#10;        Remember you can leave the experiment at any time if you feel uncomfortable.&#10;        Thank you again for your participation!&#10;        &quot;&quot;&quot;&#10;&#10;        # Insert dummy text&#10;        text_widget.insert(tk.END, dummy_text.strip())&#10;        text_widget.config(state=tk.DISABLED)  # Make text read-only&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 0))&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightblue',&#10;            command=self.show_memorizing_screen,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def show_memorizing_screen(self):&#10;        &quot;&quot;&quot;Display the memorizing screen with word pairs, information, and countdown timer&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main container&#10;        main_container = tk.Frame(self.root, bg='white')&#10;        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        # Title (smaller)&#10;        title_label = tk.Label(&#10;            main_container,&#10;            text=&quot;Memorizing Screen&quot;,&#10;            font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 5))&#10;&#10;        # Create horizontal layout: word list on left, info panel on right&#10;        content_frame = tk.Frame(main_container, bg='white')&#10;        content_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left side: Word pairs list (no scrollbar needed)&#10;        list_frame = tk.Frame(content_frame, bg='white', relief=tk.RAISED, bd=1)&#10;        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))&#10;&#10;        # List title (smaller)&#10;        list_title = tk.Label(&#10;            list_frame,&#10;            text=&quot;Word Pairs&quot;,&#10;            font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        list_title.pack(pady=3)&#10;&#10;        # Create container frame for word list (no canvas/scrollbar)&#10;        words_container = tk.Frame(list_frame, bg='white')&#10;        words_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=3)&#10;&#10;        # Display word pairs as a compact list&#10;        for index in range(len(self.first_phase_words)):&#10;            row = self.first_phase_words.iloc[index]&#10;            ice_word = row.get('ice', '')&#10;            eng_word = row.get('eng', '')&#10;&#10;            # Create frame for each word pair (more compact)&#10;            pair_frame = tk.Frame(&#10;                words_container,&#10;                bg='white',&#10;                relief=tk.SOLID,&#10;                bd=1,&#10;                padx=3,&#10;                pady=2&#10;            )&#10;            pair_frame.pack(fill=tk.X, padx=3, pady=1)&#10;&#10;            # Number label (smaller)&#10;            number_label = tk.Label(&#10;                pair_frame,&#10;                text=f&quot;{index + 1}.&quot;,&#10;                font=(&quot;Arial&quot;, 9, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                width=2,&#10;                anchor='w'&#10;            )&#10;            number_label.pack(side=tk.LEFT, padx=(0, 3))&#10;&#10;            # Icelandic word (smaller)&#10;            ice_label = tk.Label(&#10;                pair_frame,&#10;                text=ice_word,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='lightblue',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=5,&#10;                pady=2,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            ice_label.pack(side=tk.LEFT, padx=2)&#10;&#10;            # Arrow (smaller)&#10;            arrow_label = tk.Label(&#10;                pair_frame,&#10;                text=&quot;→&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black'&#10;            )&#10;            arrow_label.pack(side=tk.LEFT, padx=2)&#10;&#10;            # English word (smaller)&#10;            eng_label = tk.Label(&#10;                pair_frame,&#10;                text=eng_word,&#10;                font=(&quot;Arial&quot;, 10),&#10;                bg='lightgreen',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=5,&#10;                pady=2,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            eng_label.pack(side=tk.LEFT, padx=2)&#10;&#10;        # Right side: Information panel and timer (more compact)&#10;        info_panel = tk.Frame(content_frame, bg='lightgray', width=250, relief=tk.RAISED, bd=1)&#10;        info_panel.pack(side=tk.RIGHT, fill=tk.Y)&#10;        info_panel.pack_propagate(False)  # Maintain fixed width&#10;&#10;        # Timer display&#10;        timer_frame = tk.Frame(info_panel, bg='lightgray')&#10;        timer_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        timer_label = tk.Label(&#10;            timer_frame,&#10;            text=&quot;Time Remaining:&quot;,&#10;            font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(&#10;            timer_frame,&#10;            text=&quot;08:00&quot;,&#10;            font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='red'&#10;        )&#10;        self.timer_display.pack()&#10;&#10;        # Information text area&#10;        info_title = tk.Label(&#10;            info_panel,&#10;            text=&quot;Instructions&quot;,&#10;            font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        info_title.pack(pady=(5, 3))&#10;&#10;        # Create scrollable text widget for information&#10;        text_frame = tk.Frame(info_panel, bg='lightgray')&#10;        text_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))&#10;&#10;        info_text = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 9),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            height=8&#10;        )&#10;&#10;        info_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=info_text.yview)&#10;        info_text.configure(yscrollcommand=info_scrollbar.set)&#10;&#10;        info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Add dummy instruction text&#10;        instruction_text = &quot;&quot;&quot;&#10;        Study the word pairs carefully. You have 8 minutes to memorize the associations between the Icelandic and English words.&#10;&#10;        After the time expires, you will be tested on your remembrance of these word pairs.&#10;&#10;        Good luck with your memorization!&#10;        &quot;&quot;&quot;&#10;&#10;        info_text.insert(tk.END, instruction_text.strip())&#10;        info_text.config(state=tk.DISABLED)&#10;&#10;        # Add a Next button for testing purposes&#10;        next_button_frame = tk.Frame(info_panel, bg='lightgray')&#10;        next_button_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        next_button = tk.Button(&#10;            next_button_frame,&#10;            text=&quot;Next (Testing)&quot;,&#10;            font=(&quot;Arial&quot;, 10),&#10;            bg='orange',&#10;            fg='white',&#10;            command=self.on_timer_finished,  # Use the same function as timer completion&#10;            width=15,&#10;            height=2&#10;        )&#10;        next_button.pack()&#10;&#10;        # Start the countdown timer&#10;        self.start_countdown_timer()&#10;&#10;    def display_word_grid(self, parent_frame, word_data, start_index=0, count=25):&#10;        &quot;&quot;&quot;Display word pairs in a 5x5 grid&quot;&quot;&quot;&#10;        # Get the word pairs from the specified range&#10;        word_pairs = []&#10;        end_index = min(start_index + count, len(word_data))&#10;&#10;        for index in range(start_index, end_index):&#10;            if index &lt; len(word_data):&#10;                row = word_data.iloc[index]&#10;                ice_word = row.get('ice', '')&#10;                eng_word = row.get('eng', '')&#10;                if ice_word and eng_word:&#10;                    word_pairs.append((ice_word, eng_word))&#10;&#10;        # Pad to exactly 25 pairs if needed (5x5 grid)&#10;        while len(word_pairs) &lt; count:&#10;            word_pairs.append(('', ''))&#10;&#10;        # Create 5 rows x 5 columns grid&#10;        for row in range(5):&#10;            for col in range(5):&#10;                index = row * 5 + col&#10;                if index &lt; len(word_pairs):&#10;                    ice_word, eng_word = word_pairs[index]&#10;&#10;                    # Create frame for word pair&#10;                    pair_frame = tk.Frame(&#10;                        parent_frame,&#10;                        bg='white',&#10;                        relief=tk.RAISED,&#10;                        bd=1,&#10;                        padx=5,&#10;                        pady=5&#10;                    )&#10;                    pair_frame.grid(row=row, column=col, padx=2, pady=2, sticky='nsew')&#10;&#10;                    # Icelandic word (top)&#10;                    ice_label = tk.Label(&#10;                        pair_frame,&#10;                        text=ice_word,&#10;                        font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;                        bg='lightblue',&#10;                        fg='black',&#10;                        relief=tk.FLAT,&#10;                        padx=4,&#10;                        pady=2&#10;                    )&#10;                    ice_label.pack(fill=tk.X)&#10;&#10;                    # English word (bottom)&#10;                    eng_label = tk.Label(&#10;                        pair_frame,&#10;                        text=eng_word,&#10;                        font=(&quot;Arial&quot;, 11),&#10;                        bg='lightgreen',&#10;                        fg='black',&#10;                        relief=tk.FLAT,&#10;                        padx=4,&#10;                        pady=2&#10;                    )&#10;                    eng_label.pack(fill=tk.X)&#10;&#10;        # Configure grid weights for equal distribution&#10;        for i in range(5):&#10;            parent_frame.grid_rowconfigure(i, weight=1)&#10;        for i in range(5):&#10;            parent_frame.grid_columnconfigure(i, weight=1)&#10;&#10;    def start_countdown_timer(self):&#10;        &quot;&quot;&quot;Start the 8-minute countdown timer for FIRST memorization&quot;&quot;&quot;&#10;        self.time_remaining = 8 * 60  # 8 minutes in seconds&#10;        self.update_first_timer()&#10;&#10;    def update_first_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display for FIRST memorization&quot;&quot;&quot;&#10;        if hasattr(self, 'time_remaining') and self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 180:  # Last 3 minutes&#10;                    self.timer_display.config(fg='orange')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_first_timer)&#10;        else:&#10;            # Time's up!&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_first_timer_finished()&#10;&#10;    def on_first_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the FIRST countdown timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;First memorization time finished!&quot;)&#10;        # Use the TestScreen module with first phase words&#10;        self.test_screen = TestScreen(&#10;            root=self.root,&#10;            word_data=self.first_phase_words,&#10;            unique_id=self.unique_id,&#10;            completion_callback=self.on_first_test_completed&#10;        )&#10;&#10;    def on_first_test_completed(self, answers):&#10;        &quot;&quot;&quot;Handle FIRST test completion&quot;&quot;&quot;&#10;        print(f&quot;First test completed with {len(answers)} answers&quot;)&#10;        # Show break screen&#10;        self.show_break_screen()&#10;&#10;    def start_second_countdown_timer(self):&#10;        &quot;&quot;&quot;Start the 8-minute countdown timer for SECOND memorization&quot;&quot;&quot;&#10;        self.time_remaining_2 = 8 * 60  # 8 minutes in seconds&#10;        self.update_second_timer()&#10;&#10;    def update_second_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display for SECOND memorization&quot;&quot;&quot;&#10;        if hasattr(self, 'time_remaining_2') and self.time_remaining_2 &gt; 0:&#10;            minutes = self.time_remaining_2 // 60&#10;            seconds = self.time_remaining_2 % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining_2 &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining_2 &lt;= 180:  # Last 3 minutes&#10;                    self.timer_display.config(fg='orange')&#10;&#10;            self.time_remaining_2 -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_second_timer)&#10;        else:&#10;            # Time's up!&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_second_timer_finished()&#10;&#10;    def on_second_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the SECOND countdown timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Second memorization time finished!&quot;)&#10;        # Use the SecondTestScreen module with second phase words&#10;        self.second_test_screen = SecondTestScreen(&#10;            root=self.root,&#10;            word_data=self.second_phase_words,&#10;            unique_id=self.unique_id,&#10;            completion_callback=self.on_second_test_completed&#10;        )&#10;&#10;    def on_second_test_completed(self, answers):&#10;        &quot;&quot;&quot;Handle SECOND test completion&quot;&quot;&quot;&#10;        print(f&quot;Second test completed with {len(answers)} answers&quot;)&#10;        # Show final completion screen&#10;        self.show_final_completion_screen()&#10;&#10;    def show_final_completion_screen(self):&#10;        &quot;&quot;&quot;Display the final results screen with calculated statistics&quot;&quot;&quot;&#10;        # Calculate results from CSV&#10;        results = self.calculate_results()&#10;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Experiment Complete - Results&quot;,&#10;            font=(&quot;Arial&quot;, 28, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 20))&#10;&#10;        # Results container with scrollbar&#10;        results_frame = tk.Frame(main_frame, bg='white')&#10;        results_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Create canvas with scrollbar&#10;        canvas = tk.Canvas(results_frame, bg='white')&#10;        scrollbar = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=canvas.yview)&#10;        scrollable_frame = tk.Frame(canvas, bg='white')&#10;&#10;        scrollable_frame.bind(&#10;            &quot;&lt;Configure&gt;&quot;,&#10;            lambda e: canvas.configure(scrollregion=canvas.bbox(&quot;all&quot;))&#10;        )&#10;&#10;        canvas.create_window((0, 0), window=scrollable_frame, anchor=&quot;nw&quot;)&#10;        canvas.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Display results&#10;        if results:&#10;            # Summary Section&#10;            summary_frame = tk.Frame(scrollable_frame, bg='lightblue', relief=tk.RAISED, bd=2)&#10;            summary_frame.pack(fill=tk.X, padx=10, pady=10)&#10;&#10;            tk.Label(&#10;                summary_frame,&#10;                text=&quot;Summary Statistics&quot;,&#10;                font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;                bg='lightblue'&#10;            ).pack(pady=10)&#10;&#10;            # First Test Results&#10;            first_test_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            first_test_frame.pack(fill=tk.X, padx=20, pady=5)&#10;&#10;            tk.Label(&#10;                first_test_frame,&#10;                text=f&quot;First Test: {results['first_correct']}/{results['first_total']} correct ({results['first_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='darkgreen' if results['first_percentage'] &gt;= 50 else 'darkred'&#10;            ).pack(pady=5)&#10;&#10;            # Second Test Results&#10;            second_test_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            second_test_frame.pack(fill=tk.X, padx=20, pady=5)&#10;&#10;            tk.Label(&#10;                second_test_frame,&#10;                text=f&quot;Second Test: {results['second_correct']}/{results['second_total']} correct ({results['second_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='darkgreen' if results['second_percentage'] &gt;= 50 else 'darkred'&#10;            ).pack(pady=5)&#10;&#10;            # Overall Results&#10;            overall_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            overall_frame.pack(fill=tk.X, padx=20, pady=(5, 10))&#10;&#10;            tk.Label(&#10;                overall_frame,&#10;                text=f&quot;Overall: {results['total_correct']}/{results['total_answered']} correct ({results['overall_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='blue'&#10;            ).pack(pady=5)&#10;&#10;            # Detailed Results Section&#10;            details_frame = tk.Frame(scrollable_frame, bg='lightgray', relief=tk.RAISED, bd=2)&#10;            details_frame.pack(fill=tk.X, padx=10, pady=10)&#10;&#10;            tk.Label(&#10;                details_frame,&#10;                text=&quot;Detailed Results&quot;,&#10;                font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;                bg='lightgray'&#10;            ).pack(pady=10)&#10;&#10;            # First Test Details&#10;            if results['first_details']:&#10;                first_details_frame = tk.Frame(details_frame, bg='white', relief=tk.SOLID, bd=1)&#10;                first_details_frame.pack(fill=tk.X, padx=10, pady=5)&#10;&#10;                tk.Label(&#10;                    first_details_frame,&#10;                    text=&quot;First Test Answers:&quot;,&#10;                    font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                    bg='white'&#10;                ).pack(pady=5)&#10;&#10;                for detail in results['first_details'][:10]:  # Show first 10&#10;                    color = 'lightgreen' if detail['correct'] else 'lightcoral'&#10;                    status = '✓' if detail['correct'] else '✗'&#10;&#10;                    detail_label = tk.Label(&#10;                        first_details_frame,&#10;                        text=f&quot;{status} {detail['ice']} → {detail['answer']} (correct: {detail['eng']})&quot;,&#10;                        font=(&quot;Arial&quot;, 10),&#10;                        bg=color,&#10;                        anchor='w',&#10;                        padx=10,&#10;                        pady=2&#10;                    )&#10;                    detail_label.pack(fill=tk.X, padx=5, pady=1)&#10;&#10;            # Second Test Details&#10;            if results['second_details']:&#10;                second_details_frame = tk.Frame(details_frame, bg='white', relief=tk.SOLID, bd=1)&#10;                second_details_frame.pack(fill=tk.X, padx=10, pady=5)&#10;&#10;                tk.Label(&#10;                    second_details_frame,&#10;                    text=&quot;Second Test Answers:&quot;,&#10;                    font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                    bg='white'&#10;                ).pack(pady=5)&#10;&#10;                for detail in results['second_details'][:10]:  # Show first 10&#10;                    color = 'lightgreen' if detail['correct'] else 'lightcoral'&#10;                    status = '✓' if detail['correct'] else '✗'&#10;&#10;                    detail_label = tk.Label(&#10;                        second_details_frame,&#10;                        text=f&quot;{status} {detail['ice']} → {detail['answer']} (correct: {detail['eng']})&quot;,&#10;                        font=(&quot;Arial&quot;, 10),&#10;                        bg=color,&#10;                        anchor='w',&#10;                        padx=10,&#10;                        pady=2&#10;                    )&#10;                    detail_label.pack(fill=tk.X, padx=5, pady=1)&#10;&#10;            # Data saved message&#10;            tk.Label(&#10;                scrollable_frame,&#10;                text=f&quot;\nData saved to: {results['csv_file']}&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;italic&quot;),&#10;                bg='white',&#10;                fg='gray'&#10;            ).pack(pady=10)&#10;&#10;        else:&#10;            # Error message if results couldn't be calculated&#10;            tk.Label(&#10;                scrollable_frame,&#10;                text=&quot;Error calculating results.\nPlease check the data file.&quot;,&#10;                font=(&quot;Arial&quot;, 16),&#10;                bg='white',&#10;                fg='red'&#10;            ).pack(pady=50)&#10;&#10;        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Thank you message at bottom&#10;        thank_you_frame = tk.Frame(main_frame, bg='white')&#10;        thank_you_frame.pack(side=tk.BOTTOM, pady=10)&#10;&#10;        tk.Label(&#10;            thank_you_frame,&#10;            text=&quot;Thank you for your participation!&quot;,&#10;            font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='green'&#10;        ).pack()&#10;&#10;    def calculate_results(self):&#10;        &quot;&quot;&quot;Calculate results from the CSV file&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return None&#10;&#10;            # Find the CSV file for this session&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if not csv_files:&#10;                print(&quot;No CSV file found&quot;)&#10;                return None&#10;&#10;            csv_files.sort()&#10;            latest_csv = os.path.join(data_dir, csv_files[-1])&#10;&#10;            print(f&quot;Calculating results from: {latest_csv}&quot;)&#10;&#10;            # Read the CSV file&#10;            df = pd.read_csv(latest_csv)&#10;&#10;            # Initialize counters&#10;            first_correct = 0&#10;            first_total = 0&#10;            second_correct = 0&#10;            second_total = 0&#10;&#10;            first_details = []&#10;            second_details = []&#10;&#10;            # Process each row&#10;            for _, row in df.iterrows():&#10;                ice_word = str(row.get('ice', '')).strip().lower()&#10;                eng_word = str(row.get('eng', '')).strip().lower()&#10;                answer_1 = str(row.get('answ_1', '')).strip().lower()&#10;                answer_2 = str(row.get('answ_2', '')).strip().lower()&#10;&#10;                # Check first test answer&#10;                if answer_1:&#10;                    first_total += 1&#10;                    is_correct = (answer_1 == eng_word)&#10;                    if is_correct:&#10;                        first_correct += 1&#10;                    first_details.append({&#10;                        'ice': row.get('ice', ''),&#10;                        'eng': row.get('eng', ''),&#10;                        'answer': row.get('answ_1', ''),&#10;                        'correct': is_correct&#10;                    })&#10;&#10;                # Check second test answer&#10;                if answer_2:&#10;                    second_total += 1&#10;                    is_correct = (answer_2 == eng_word)&#10;                    if is_correct:&#10;                        second_correct += 1&#10;                    second_details.append({&#10;                        'ice': row.get('ice', ''),&#10;                        'eng': row.get('eng', ''),&#10;                        'answer': row.get('answ_2', ''),&#10;                        'correct': is_correct&#10;                    })&#10;&#10;            # Calculate percentages&#10;            first_percentage = (first_correct / first_total * 100) if first_total &gt; 0 else 0&#10;            second_percentage = (second_correct / second_total * 100) if second_total &gt; 0 else 0&#10;            total_correct = first_correct + second_correct&#10;            total_answered = first_total + second_total&#10;            overall_percentage = (total_correct / total_answered * 100) if total_answered &gt; 0 else 0&#10;&#10;            results = {&#10;                'first_correct': first_correct,&#10;                'first_total': first_total,&#10;                'first_percentage': first_percentage,&#10;                'second_correct': second_correct,&#10;                'second_total': second_total,&#10;                'second_percentage': second_percentage,&#10;                'total_correct': total_correct,&#10;                'total_answered': total_answered,&#10;                'overall_percentage': overall_percentage,&#10;                'first_details': first_details,&#10;                'second_details': second_details,&#10;                'csv_file': latest_csv&#10;            }&#10;&#10;            print(f&quot;Results calculated:&quot;)&#10;            print(f&quot;  First Test: {first_correct}/{first_total} ({first_percentage:.1f}%)&quot;)&#10;            print(f&quot;  Second Test: {second_correct}/{second_total} ({second_percentage:.1f}%)&quot;)&#10;            print(f&quot;  Overall: {total_correct}/{total_answered} ({overall_percentage:.1f}%)&quot;)&#10;&#10;            return results&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error calculating results: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the first countdown timer reaches zero - compatibility method&quot;&quot;&quot;&#10;        self.on_first_timer_finished()&#10;&#10;    def show_break_screen(self):&#10;        &quot;&quot;&quot;Display the break screen with dummy text&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Break Time&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 30))&#10;&#10;        # Create text frame with scrollbar&#10;        text_frame = tk.Frame(main_frame, bg='white')&#10;        text_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Text widget with scrollbar&#10;        text_widget = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            padx=20,&#10;            pady=20&#10;        )&#10;&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Pack text widget and scrollbar&#10;        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Break screen dummy text&#10;        break_text = &quot;&quot;&quot;&#10;        Great job completing the first test!&#10;&#10;        You have now finished the first memory test. Take a moment to relax and rest your mind.&#10;&#10;        During this break, you can:&#10;        • Take a deep breath and relax&#10;        • Stretch if you need to&#10;        • Clear your mind from the previous task&#10;&#10;        The next part of the experiment will begin when you click the &quot;Next&quot; button below.&#10;&#10;        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&#10;&#10;        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&#10;&#10;        When you're ready to continue with the next phase of the experiment, please click the &quot;Next&quot; button.&#10;&#10;        Thank you for your continued participation in this cognitive science research!&#10;        &quot;&quot;&quot;&#10;&#10;        # Insert break text&#10;        text_widget.insert(tk.END, break_text.strip())&#10;        text_widget.config(state=tk.DISABLED)  # Make text read-only&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 0))&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightgreen',&#10;            command=self.on_break_next_clicked,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def on_break_next_clicked(self):&#10;        &quot;&quot;&quot;Handle next button click from break screen&quot;&quot;&quot;&#10;        print(&quot;Break completed, moving to second memorizing screen&quot;)&#10;        # Show second memorizing screen before the second test&#10;        self.show_second_memorizing_screen()&#10;&#10;    def show_second_memorizing_screen(self):&#10;        &quot;&quot;&quot;Display the second memorizing screen with word pairs before the second test&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main container&#10;        main_container = tk.Frame(self.root, bg='white')&#10;        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        # Title (smaller)&#10;        title_label = tk.Label(&#10;            main_container,&#10;            text=&quot;Memorizing Screen - Round 2&quot;,&#10;            font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 5))&#10;&#10;        # Create horizontal layout: word list on left, info panel on right&#10;        content_frame = tk.Frame(main_container, bg='white')&#10;        content_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left side: Word pairs list (no scrollbar needed)&#10;        list_frame = tk.Frame(content_frame, bg='white', relief=tk.RAISED, bd=1)&#10;        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))&#10;&#10;        # List title (smaller)&#10;        list_title = tk.Label(&#10;            list_frame,&#10;            text=&quot;Word Pairs&quot;,&#10;            font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        list_title.pack(pady=3)&#10;&#10;        # Create container frame for word list (no canvas/scrollbar)&#10;        words_container = tk.Frame(list_frame, bg='white')&#10;        words_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=3)&#10;&#10;        # Display word pairs as a compact list&#10;        for index in range(len(self.second_phase_words)):&#10;            row = self.second_phase_words.iloc[index]&#10;            ice_word = row.get('ice', '')&#10;            eng_word = row.get('eng', '')&#10;&#10;            # Create frame for each word pair (more compact)&#10;            pair_frame = tk.Frame(&#10;                words_container,&#10;                bg='white',&#10;                relief=tk.SOLID,&#10;                bd=1,&#10;                padx=3,&#10;                pady=2&#10;            )&#10;            pair_frame.pack(fill=tk.X, padx=3, pady=1)&#10;&#10;            # Number label (smaller)&#10;            number_label = tk.Label(&#10;                pair_frame,&#10;                text=f&quot;{index + 1}.&quot;,&#10;                font=(&quot;Arial&quot;, 9, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                width=2,&#10;                anchor='w'&#10;            )&#10;            number_label.pack(side=tk.LEFT, padx=(0, 3))&#10;&#10;            # Icelandic word (smaller)&#10;            ice_label = tk.Label(&#10;                pair_frame,&#10;                text=ice_word,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='lightblue',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=5,&#10;                pady=2,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            ice_label.pack(side=tk.LEFT, padx=2)&#10;&#10;            # Arrow (smaller)&#10;            arrow_label = tk.Label(&#10;                pair_frame,&#10;                text=&quot;→&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black'&#10;            )&#10;            arrow_label.pack(side=tk.LEFT, padx=2)&#10;&#10;            # English word (smaller)&#10;            eng_label = tk.Label(&#10;                pair_frame,&#10;                text=eng_word,&#10;                font=(&quot;Arial&quot;, 10),&#10;                bg='lightgreen',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=5,&#10;                pady=2,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            eng_label.pack(side=tk.LEFT, padx=2)&#10;&#10;        # Right side: Information panel and timer (more compact)&#10;        info_panel = tk.Frame(content_frame, bg='lightgray', width=250, relief=tk.RAISED, bd=1)&#10;        info_panel.pack(side=tk.RIGHT, fill=tk.Y)&#10;        info_panel.pack_propagate(False)  # Maintain fixed width&#10;&#10;        # Timer display&#10;        timer_frame = tk.Frame(info_panel, bg='lightgray')&#10;        timer_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        timer_label = tk.Label(&#10;            timer_frame,&#10;            text=&quot;Time Remaining:&quot;,&#10;            font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(&#10;            timer_frame,&#10;            text=&quot;08:00&quot;,&#10;            font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='red'&#10;        )&#10;        self.timer_display.pack()&#10;&#10;        # Information text area&#10;        info_title = tk.Label(&#10;            info_panel,&#10;            text=&quot;Instructions&quot;,&#10;            font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        info_title.pack(pady=(5, 3))&#10;&#10;        # Create scrollable text widget for information&#10;        text_frame = tk.Frame(info_panel, bg='lightgray')&#10;        text_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))&#10;&#10;        info_text = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 9),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            height=8&#10;        )&#10;&#10;        info_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=info_text.yview)&#10;        info_text.configure(yscrollcommand=info_scrollbar.set)&#10;&#10;        info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Add instruction text for second memorization session&#10;        instruction_text = &quot;&quot;&quot;&#10;        Review the word pairs again. You have 8 minutes to refresh your memory of the associations between the Icelandic and English words.&#10;&#10;        After the time expires, you will be tested again on your remembrance of these word pairs. The questions will be presented in a different order.&#10;&#10;        Good luck with your second memorization session!&#10;        &quot;&quot;&quot;&#10;&#10;        info_text.insert(tk.END, instruction_text.strip())&#10;        info_text.config(state=tk.DISABLED)&#10;&#10;        # Add a Next button for testing purposes&#10;        next_button_frame = tk.Frame(info_panel, bg='lightgray')&#10;        next_button_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        next_button = tk.Button(&#10;            next_button_frame,&#10;            text=&quot;Next (Testing)&quot;,&#10;            font=(&quot;Arial&quot;, 10),&#10;            bg='orange',&#10;            fg='white',&#10;            command=self.on_second_timer_finished,&#10;            width=15,&#10;            height=2&#10;        )&#10;        next_button.pack()&#10;&#10;        # Start the countdown timer for second memorization&#10;        self.start_second_countdown_timer()&#10;&#10;def main():&#10;    root = tk.Tk()&#10;    app = ExperimentApp(root)&#10;    root.mainloop()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;from tkinter import ttk&#10;import pandas as pd&#10;import csv&#10;import uuid&#10;import os&#10;import random&#10;from datetime import datetime&#10;from test_screen import TestScreen&#10;from second_test_screen import SecondTestScreen&#10;&#10;class ExperimentApp:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Cognitive Science Experiment&quot;)&#10;        self.root.geometry(&quot;800x600&quot;)&#10;        self.root.configure(bg='white')&#10;&#10;        # Generate unique ID for this session&#10;        self.unique_id = str(uuid.uuid4())[:8]  # Short unique ID&#10;&#10;        # Load word data&#10;        self.word_data = self.load_word_data()&#10;&#10;        # Select random words for both phases&#10;        self.select_random_word_sets()&#10;&#10;        # Show welcome screen&#10;        self.show_welcome_screen()&#10;&#10;    def select_random_word_sets(self):&#10;        &quot;&quot;&quot;Select two sets of 25 random words for the two experiment phases&quot;&quot;&quot;&#10;        total_words = len(self.word_data)&#10;&#10;        if total_words &lt; 50:&#10;            print(f&quot;Warning: Only {total_words} words available. Need at least 50 for two sets of 25.&quot;)&#10;            # If we don't have enough words, use what we have&#10;            all_indices = list(range(total_words))&#10;            random.shuffle(all_indices)&#10;&#10;            mid_point = min(25, total_words // 2)&#10;            self.first_phase_indices = all_indices[:mid_point]&#10;            self.second_phase_indices = all_indices[mid_point:min(mid_point * 2, total_words)]&#10;        else:&#10;            # Randomly select 50 unique indices&#10;            all_indices = list(range(total_words))&#10;            random.shuffle(all_indices)&#10;&#10;            # First 25 for phase 1, next 25 for phase 2&#10;            self.first_phase_indices = sorted(all_indices[:25])&#10;            self.second_phase_indices = sorted(all_indices[25:50])&#10;&#10;        # Create DataFrames for each phase - keep original indices for CSV matching&#10;        # Reset index but keep the original word_id for matching&#10;        self.first_phase_words = self.word_data.iloc[self.first_phase_indices].copy()&#10;        self.first_phase_words.reset_index(drop=True, inplace=True)&#10;&#10;        self.second_phase_words = self.word_data.iloc[self.second_phase_indices].copy()&#10;        self.second_phase_words.reset_index(drop=True, inplace=True)&#10;&#10;        print(f&quot;Phase 1 word indices: {self.first_phase_indices}&quot;)&#10;        print(f&quot;Phase 2 word indices: {self.second_phase_indices}&quot;)&#10;        print(f&quot;Phase 1 first word: {self.first_phase_words.iloc[0]['ice']} -&gt; {self.first_phase_words.iloc[0]['eng']} (word_id: {self.first_phase_words.iloc[0]['word_id']})&quot;)&#10;        print(f&quot;Phase 2 first word: {self.second_phase_words.iloc[0]['ice']} -&gt; {self.second_phase_words.iloc[0]['eng']} (word_id: {self.second_phase_words.iloc[0]['word_id']})&quot;)&#10;&#10;    def load_word_data(self):&#10;        &quot;&quot;&quot;Load word data from Excel file&quot;&quot;&quot;&#10;        try:&#10;            df = pd.read_excel('../word_pairs/Icelandic_English_Danish_words.xlsx')&#10;            print(f&quot;Excel file loaded successfully! Shape: {df.shape}&quot;)&#10;            print(f&quot;Columns: {df.columns.tolist()}&quot;)&#10;&#10;            # Check if the Excel file has the expected columns&#10;            # Try different possible column name variations&#10;            ice_col = None&#10;            eng_col = None&#10;            word_id_col = None&#10;&#10;            # Look for Icelandic column (could be 'ice', 'icelandic', or index-based)&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'ice' in col_str or 'island' in col_str:&#10;                    ice_col = col&#10;                    break&#10;&#10;            # Look for English column (could be 'eng', 'english', or index-based)&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'eng' in col_str or 'english' in col_str:&#10;                    eng_col = col&#10;                    break&#10;&#10;            # Look for word_id column&#10;            for col in df.columns:&#10;                col_str = str(col).lower()&#10;                if 'word_id' in col_str or 'id' in col_str:&#10;                    word_id_col = col&#10;                    break&#10;&#10;            # If we can't find named columns, assume columns by position&#10;            if ice_col is None and eng_col is None:&#10;                if len(df.columns) &gt;= 2:&#10;                    # Assume first column is Icelandic, second is English&#10;                    ice_col = df.columns[0]&#10;                    eng_col = df.columns[1]&#10;&#10;            print(f&quot;Using columns - word_id: {word_id_col}, ice: {ice_col}, eng: {eng_col}&quot;)&#10;&#10;            # Create standardized DataFrame&#10;            result_data = []&#10;            for index, row in df.iterrows():&#10;                word_id = row[word_id_col] if word_id_col else index + 1&#10;                ice_word = row[ice_col] if ice_col else ''&#10;                eng_word = row[eng_col] if eng_col else ''&#10;&#10;                result_data.append({&#10;                    'word_id': word_id,&#10;                    'ice': ice_word,&#10;                    'eng': eng_word&#10;                })&#10;&#10;            result_df = pd.DataFrame(result_data)&#10;            print(f&quot;Processed {len(result_df)} word pairs&quot;)&#10;            print(&quot;First few pairs:&quot;)&#10;            for i in range(min(5, len(result_df))):&#10;                row = result_df.iloc[i]&#10;                print(f&quot;  {i+1}: {row['ice']} -&gt; {row['eng']}&quot;)&#10;&#10;            return result_df&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error loading word data: {e}&quot;)&#10;            # Create dummy data if file doesn't exist or can't be read&#10;            return pd.DataFrame({&#10;                'word_id': [1, 2, 3, 4, 5],&#10;                'ice': ['hestur', 'hundur', 'köttur', 'fugl', 'fiskur'],&#10;                'eng': ['horse', 'dog', 'cat', 'bird', 'fish']&#10;            })&#10;&#10;    def show_welcome_screen(self):&#10;        &quot;&quot;&quot;Display the welcome screen&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Welcome message&#10;        welcome_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Welcome&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        welcome_label.pack(expand=True)&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=20)&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightblue',&#10;            command=self.on_next_clicked,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def on_next_clicked(self):&#10;        &quot;&quot;&quot;Handle next button click - create CSV and show information screen&quot;&quot;&quot;&#10;        self.create_csv_file()&#10;        self.show_information_screen()&#10;&#10;    def create_csv_file(self):&#10;        &quot;&quot;&quot;Create CSV file with unique name and populate with data&quot;&quot;&quot;&#10;        # Create unique filename with timestamp&#10;        timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)&#10;        filename = f&quot;../data/experiment_{self.unique_id}_{timestamp}.csv&quot;&#10;&#10;        # Ensure data directory exists&#10;        os.makedirs(&quot;../data&quot;, exist_ok=True)&#10;&#10;        # Prepare data for CSV&#10;        csv_data = []&#10;&#10;        # Add header&#10;        csv_data.append(['id', 'word_id', 'ice', 'eng', 'answ_1', 'answ_2'])&#10;&#10;        # Add data rows&#10;        for index, row in self.word_data.iterrows():&#10;            csv_row = [&#10;                self.unique_id,  # unique id&#10;                int(row.get('word_id', index + 1)),  # word_id from Excel or index&#10;                row.get('ice', ''),  # Icelandic word&#10;                row.get('eng', ''),  # English word&#10;                '',  # answ_1 - empty for now&#10;                ''   # answ_2 - empty for now&#10;            ]&#10;            csv_data.append(csv_row)&#10;&#10;        # Write to CSV file&#10;        try:&#10;            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:&#10;                writer = csv.writer(csvfile)&#10;                writer.writerows(csv_data)&#10;            print(f&quot;CSV file created: {filename}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error creating CSV file: {e}&quot;)&#10;&#10;    def show_information_screen(self):&#10;        &quot;&quot;&quot;Display the information screen with dummy text&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Information&quot;,&#10;            font=(&quot;Arial&quot;, 24, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 20))&#10;&#10;        # Create text frame with scrollbar&#10;        text_frame = tk.Frame(main_frame, bg='white')&#10;        text_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Text widget with scrollbar&#10;        text_widget = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 12),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            padx=10,&#10;            pady=10&#10;        )&#10;&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Pack text widget and scrollbar&#10;        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Dummy text content&#10;        dummy_text = &quot;&quot;&quot;&#10;                Welcome to this cognitive science experiment.&#10;        &#10;        We are very grateful for your participation.&#10;        This experiment consists of several parts, including memorization and recall tasks.&#10;        First you will be presented with a list of word pairs to memorize in 8 minutes.&#10;        After a set period of time, you will be tested for 3 minutes on your memory of these word pairs.&#10;        Then you will watch YouTube short for 8 minutes.&#10;        Finally, you will be tested again on your memory of the word pairs for 3 minutes.&#10;        Your responses will be recorded in a text file for analysis.&#10;        &#10;        If you have any questions, feel free to ask the experimenter before we begin.&#10;        Remember you can leave the experiment at any time if you feel uncomfortable.&#10;        Thank you again for your participation!&#10;        &quot;&quot;&quot;&#10;&#10;        # Insert dummy text&#10;        text_widget.insert(tk.END, dummy_text.strip())&#10;        text_widget.config(state=tk.DISABLED)  # Make text read-only&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 0))&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightblue',&#10;            command=self.show_memorizing_screen,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def show_memorizing_screen(self):&#10;        &quot;&quot;&quot;Display the memorizing screen with word pairs, information, and countdown timer&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main container&#10;        main_container = tk.Frame(self.root, bg='white')&#10;        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        # Title (smaller)&#10;        title_label = tk.Label(&#10;            main_container,&#10;            text=&quot;Memorizing Screen&quot;,&#10;            font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 5))&#10;&#10;        # Create horizontal layout: word list on left, info panel on right&#10;        content_frame = tk.Frame(main_container, bg='white')&#10;        content_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left side: Word pairs list (no scrollbar needed)&#10;        list_frame = tk.Frame(content_frame, bg='white', relief=tk.RAISED, bd=1)&#10;        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))&#10;&#10;        # List title (smaller)&#10;        list_title = tk.Label(&#10;            list_frame,&#10;            text=&quot;Word Pairs&quot;,&#10;            font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        list_title.pack(pady=3)&#10;&#10;        # Create container frame for word list (no canvas/scrollbar)&#10;        words_container = tk.Frame(list_frame, bg='white')&#10;        words_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)&#10;&#10;        # Display word pairs as a compact list&#10;        for index in range(len(self.first_phase_words)):&#10;            row = self.first_phase_words.iloc[index]&#10;            ice_word = row.get('ice', '')&#10;            eng_word = row.get('eng', '')&#10;&#10;            # Create frame for each word pair (minimal padding)&#10;            pair_frame = tk.Frame(&#10;                words_container,&#10;                bg='white',&#10;                relief=tk.FLAT,&#10;                bd=0,&#10;                padx=1,&#10;                pady=0&#10;            )&#10;            pair_frame.pack(fill=tk.X, padx=1, pady=0)&#10;&#10;            # Number label (smaller)&#10;            number_label = tk.Label(&#10;                pair_frame,&#10;                text=f&quot;{index + 1}.&quot;,&#10;                font=(&quot;Arial&quot;, 9, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                width=2,&#10;                anchor='w'&#10;            )&#10;            number_label.pack(side=tk.LEFT, padx=(0, 2))&#10;&#10;            # Icelandic word (no background color)&#10;            ice_label = tk.Label(&#10;                pair_frame,&#10;                text=ice_word,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=2,&#10;                pady=0,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            ice_label.pack(side=tk.LEFT, padx=1)&#10;&#10;            # Arrow (smaller)&#10;            arrow_label = tk.Label(&#10;                pair_frame,&#10;                text=&quot;→&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black'&#10;            )&#10;            arrow_label.pack(side=tk.LEFT, padx=1)&#10;&#10;            # English word (no background color)&#10;            eng_label = tk.Label(&#10;                pair_frame,&#10;                text=eng_word,&#10;                font=(&quot;Arial&quot;, 10),&#10;                bg='white',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=2,&#10;                pady=0,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            eng_label.pack(side=tk.LEFT, padx=1)&#10;&#10;        # Right side: Information panel and timer (more compact)&#10;        info_panel = tk.Frame(content_frame, bg='lightgray', width=250, relief=tk.RAISED, bd=1)&#10;        info_panel.pack(side=tk.RIGHT, fill=tk.Y)&#10;        info_panel.pack_propagate(False)  # Maintain fixed width&#10;&#10;        # Timer display&#10;        timer_frame = tk.Frame(info_panel, bg='lightgray')&#10;        timer_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        timer_label = tk.Label(&#10;            timer_frame,&#10;            text=&quot;Time Remaining:&quot;,&#10;            font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(&#10;            timer_frame,&#10;            text=&quot;08:00&quot;,&#10;            font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='red'&#10;        )&#10;        self.timer_display.pack()&#10;&#10;        # Information text area&#10;        info_title = tk.Label(&#10;            info_panel,&#10;            text=&quot;Instructions&quot;,&#10;            font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        info_title.pack(pady=(5, 3))&#10;&#10;        # Create scrollable text widget for information&#10;        text_frame = tk.Frame(info_panel, bg='lightgray')&#10;        text_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))&#10;&#10;        info_text = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 9),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            height=8&#10;        )&#10;&#10;        info_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=info_text.yview)&#10;        info_text.configure(yscrollcommand=info_scrollbar.set)&#10;&#10;        info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Add dummy instruction text&#10;        instruction_text = &quot;&quot;&quot;&#10;        Study the word pairs carefully. You have 8 minutes to memorize the associations between the Icelandic and English words.&#10;&#10;        After the time expires, you will be tested on your remembrance of these word pairs.&#10;&#10;        Good luck with your memorization!&#10;        &quot;&quot;&quot;&#10;&#10;        info_text.insert(tk.END, instruction_text.strip())&#10;        info_text.config(state=tk.DISABLED)&#10;&#10;        # Add a Next button for testing purposes&#10;        next_button_frame = tk.Frame(info_panel, bg='lightgray')&#10;        next_button_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        next_button = tk.Button(&#10;            next_button_frame,&#10;            text=&quot;Next (Testing)&quot;,&#10;            font=(&quot;Arial&quot;, 10),&#10;            bg='orange',&#10;            fg='white',&#10;            command=self.on_timer_finished,  # Use the same function as timer completion&#10;            width=15,&#10;            height=2&#10;        )&#10;        next_button.pack()&#10;&#10;        # Start the countdown timer&#10;        self.start_countdown_timer()&#10;&#10;    def display_word_grid(self, parent_frame, word_data, start_index=0, count=25):&#10;        &quot;&quot;&quot;Display word pairs in a 5x5 grid&quot;&quot;&quot;&#10;        # Get the word pairs from the specified range&#10;        word_pairs = []&#10;        end_index = min(start_index + count, len(word_data))&#10;&#10;        for index in range(start_index, end_index):&#10;            if index &lt; len(word_data):&#10;                row = word_data.iloc[index]&#10;                ice_word = row.get('ice', '')&#10;                eng_word = row.get('eng', '')&#10;                if ice_word and eng_word:&#10;                    word_pairs.append((ice_word, eng_word))&#10;&#10;        # Pad to exactly 25 pairs if needed (5x5 grid)&#10;        while len(word_pairs) &lt; count:&#10;            word_pairs.append(('', ''))&#10;&#10;        # Create 5 rows x 5 columns grid&#10;        for row in range(5):&#10;            for col in range(5):&#10;                index = row * 5 + col&#10;                if index &lt; len(word_pairs):&#10;                    ice_word, eng_word = word_pairs[index]&#10;&#10;                    # Create frame for word pair&#10;                    pair_frame = tk.Frame(&#10;                        parent_frame,&#10;                        bg='white',&#10;                        relief=tk.RAISED,&#10;                        bd=1,&#10;                        padx=5,&#10;                        pady=5&#10;                    )&#10;                    pair_frame.grid(row=row, column=col, padx=2, pady=2, sticky='nsew')&#10;&#10;                    # Icelandic word (top)&#10;                    ice_label = tk.Label(&#10;                        pair_frame,&#10;                        text=ice_word,&#10;                        font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;                        bg='lightblue',&#10;                        fg='black',&#10;                        relief=tk.FLAT,&#10;                        padx=4,&#10;                        pady=2&#10;                    )&#10;                    ice_label.pack(fill=tk.X)&#10;&#10;                    # English word (bottom)&#10;                    eng_label = tk.Label(&#10;                        pair_frame,&#10;                        text=eng_word,&#10;                        font=(&quot;Arial&quot;, 11),&#10;                        bg='lightgreen',&#10;                        fg='black',&#10;                        relief=tk.FLAT,&#10;                        padx=4,&#10;                        pady=2&#10;                    )&#10;                    eng_label.pack(fill=tk.X)&#10;&#10;        # Configure grid weights for equal distribution&#10;        for i in range(5):&#10;            parent_frame.grid_rowconfigure(i, weight=1)&#10;        for i in range(5):&#10;            parent_frame.grid_columnconfigure(i, weight=1)&#10;&#10;    def start_countdown_timer(self):&#10;        &quot;&quot;&quot;Start the 8-minute countdown timer for FIRST memorization&quot;&quot;&quot;&#10;        self.time_remaining = 8 * 60  # 8 minutes in seconds&#10;        self.update_first_timer()&#10;&#10;    def update_first_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display for FIRST memorization&quot;&quot;&quot;&#10;        if hasattr(self, 'time_remaining') and self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 180:  # Last 3 minutes&#10;                    self.timer_display.config(fg='orange')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_first_timer)&#10;        else:&#10;            # Time's up!&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_first_timer_finished()&#10;&#10;    def on_first_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the FIRST countdown timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;First memorization time finished!&quot;)&#10;        # Use the TestScreen module with first phase words&#10;        self.test_screen = TestScreen(&#10;            root=self.root,&#10;            word_data=self.first_phase_words,&#10;            unique_id=self.unique_id,&#10;            completion_callback=self.on_first_test_completed&#10;        )&#10;&#10;    def on_first_test_completed(self, answers):&#10;        &quot;&quot;&quot;Handle FIRST test completion&quot;&quot;&quot;&#10;        print(f&quot;First test completed with {len(answers)} answers&quot;)&#10;        # Show break screen&#10;        self.show_break_screen()&#10;&#10;    def start_second_countdown_timer(self):&#10;        &quot;&quot;&quot;Start the 8-minute countdown timer for SECOND memorization&quot;&quot;&quot;&#10;        self.time_remaining_2 = 8 * 60  # 8 minutes in seconds&#10;        self.update_second_timer()&#10;&#10;    def update_second_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display for SECOND memorization&quot;&quot;&quot;&#10;        if hasattr(self, 'time_remaining_2') and self.time_remaining_2 &gt; 0:&#10;            minutes = self.time_remaining_2 // 60&#10;            seconds = self.time_remaining_2 % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining_2 &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining_2 &lt;= 180:  # Last 3 minutes&#10;                    self.timer_display.config(fg='orange')&#10;&#10;            self.time_remaining_2 -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_second_timer)&#10;        else:&#10;            # Time's up!&#10;            if hasattr(self, 'timer_display'):&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_second_timer_finished()&#10;&#10;    def on_second_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the SECOND countdown timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Second memorization time finished!&quot;)&#10;        # Use the SecondTestScreen module with second phase words&#10;        self.second_test_screen = SecondTestScreen(&#10;            root=self.root,&#10;            word_data=self.second_phase_words,&#10;            unique_id=self.unique_id,&#10;            completion_callback=self.on_second_test_completed&#10;        )&#10;&#10;    def on_second_test_completed(self, answers):&#10;        &quot;&quot;&quot;Handle SECOND test completion&quot;&quot;&quot;&#10;        print(f&quot;Second test completed with {len(answers)} answers&quot;)&#10;        # Show final completion screen&#10;        self.show_final_completion_screen()&#10;&#10;    def show_final_completion_screen(self):&#10;        &quot;&quot;&quot;Display the final results screen with calculated statistics&quot;&quot;&quot;&#10;        # Calculate results from CSV&#10;        results = self.calculate_results()&#10;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Experiment Complete - Results&quot;,&#10;            font=(&quot;Arial&quot;, 28, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 20))&#10;&#10;        # Results container with scrollbar&#10;        results_frame = tk.Frame(main_frame, bg='white')&#10;        results_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Create canvas with scrollbar&#10;        canvas = tk.Canvas(results_frame, bg='white')&#10;        scrollbar = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=canvas.yview)&#10;        scrollable_frame = tk.Frame(canvas, bg='white')&#10;&#10;        scrollable_frame.bind(&#10;            &quot;&lt;Configure&gt;&quot;,&#10;            lambda e: canvas.configure(scrollregion=canvas.bbox(&quot;all&quot;))&#10;        )&#10;&#10;        canvas.create_window((0, 0), window=scrollable_frame, anchor=&quot;nw&quot;)&#10;        canvas.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Display results&#10;        if results:&#10;            # Summary Section&#10;            summary_frame = tk.Frame(scrollable_frame, bg='lightblue', relief=tk.RAISED, bd=2)&#10;            summary_frame.pack(fill=tk.X, padx=10, pady=10)&#10;&#10;            tk.Label(&#10;                summary_frame,&#10;                text=&quot;Summary Statistics&quot;,&#10;                font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;                bg='lightblue'&#10;            ).pack(pady=10)&#10;&#10;            # First Test Results&#10;            first_test_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            first_test_frame.pack(fill=tk.X, padx=20, pady=5)&#10;&#10;            tk.Label(&#10;                first_test_frame,&#10;                text=f&quot;First Test: {results['first_correct']}/{results['first_total']} correct ({results['first_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='darkgreen' if results['first_percentage'] &gt;= 50 else 'darkred'&#10;            ).pack(pady=5)&#10;&#10;            # Second Test Results&#10;            second_test_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            second_test_frame.pack(fill=tk.X, padx=20, pady=5)&#10;&#10;            tk.Label(&#10;                second_test_frame,&#10;                text=f&quot;Second Test: {results['second_correct']}/{results['second_total']} correct ({results['second_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='darkgreen' if results['second_percentage'] &gt;= 50 else 'darkred'&#10;            ).pack(pady=5)&#10;&#10;            # Overall Results&#10;            overall_frame = tk.Frame(summary_frame, bg='white', relief=tk.SOLID, bd=1)&#10;            overall_frame.pack(fill=tk.X, padx=20, pady=(5, 10))&#10;&#10;            tk.Label(&#10;                overall_frame,&#10;                text=f&quot;Overall: {results['total_correct']}/{results['total_answered']} correct ({results['overall_percentage']:.1f}%)&quot;,&#10;                font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='blue'&#10;            ).pack(pady=5)&#10;&#10;            # Detailed Results Section&#10;            details_frame = tk.Frame(scrollable_frame, bg='lightgray', relief=tk.RAISED, bd=2)&#10;            details_frame.pack(fill=tk.X, padx=10, pady=10)&#10;&#10;            tk.Label(&#10;                details_frame,&#10;                text=&quot;Detailed Results&quot;,&#10;                font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;                bg='lightgray'&#10;            ).pack(pady=10)&#10;&#10;            # First Test Details&#10;            if results['first_details']:&#10;                first_details_frame = tk.Frame(details_frame, bg='white', relief=tk.SOLID, bd=1)&#10;                first_details_frame.pack(fill=tk.X, padx=10, pady=5)&#10;&#10;                tk.Label(&#10;                    first_details_frame,&#10;                    text=&quot;First Test Answers:&quot;,&#10;                    font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                    bg='white'&#10;                ).pack(pady=5)&#10;&#10;                for detail in results['first_details'][:10]:  # Show first 10&#10;                    color = 'lightgreen' if detail['correct'] else 'lightcoral'&#10;                    status = '✓' if detail['correct'] else '✗'&#10;&#10;                    detail_label = tk.Label(&#10;                        first_details_frame,&#10;                        text=f&quot;{status} {detail['ice']} → {detail['answer']} (correct: {detail['eng']})&quot;,&#10;                        font=(&quot;Arial&quot;, 10),&#10;                        bg=color,&#10;                        anchor='w',&#10;                        padx=10,&#10;                        pady=2&#10;                    )&#10;                    detail_label.pack(fill=tk.X, padx=5, pady=1)&#10;&#10;            # Second Test Details&#10;            if results['second_details']:&#10;                second_details_frame = tk.Frame(details_frame, bg='white', relief=tk.SOLID, bd=1)&#10;                second_details_frame.pack(fill=tk.X, padx=10, pady=5)&#10;&#10;                tk.Label(&#10;                    second_details_frame,&#10;                    text=&quot;Second Test Answers:&quot;,&#10;                    font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                    bg='white'&#10;                ).pack(pady=5)&#10;&#10;                for detail in results['second_details'][:10]:  # Show first 10&#10;                    color = 'lightgreen' if detail['correct'] else 'lightcoral'&#10;                    status = '✓' if detail['correct'] else '✗'&#10;&#10;                    detail_label = tk.Label(&#10;                        second_details_frame,&#10;                        text=f&quot;{status} {detail['ice']} → {detail['answer']} (correct: {detail['eng']})&quot;,&#10;                        font=(&quot;Arial&quot;, 10),&#10;                        bg=color,&#10;                        anchor='w',&#10;                        padx=10,&#10;                        pady=2&#10;                    )&#10;                    detail_label.pack(fill=tk.X, padx=5, pady=1)&#10;&#10;            # Data saved message&#10;            tk.Label(&#10;                scrollable_frame,&#10;                text=f&quot;\nData saved to: {results['csv_file']}&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;italic&quot;),&#10;                bg='white',&#10;                fg='gray'&#10;            ).pack(pady=10)&#10;&#10;        else:&#10;            # Error message if results couldn't be calculated&#10;            tk.Label(&#10;                scrollable_frame,&#10;                text=&quot;Error calculating results.\nPlease check the data file.&quot;,&#10;                font=(&quot;Arial&quot;, 16),&#10;                bg='white',&#10;                fg='red'&#10;            ).pack(pady=50)&#10;&#10;        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Thank you message at bottom&#10;        thank_you_frame = tk.Frame(main_frame, bg='white')&#10;        thank_you_frame.pack(side=tk.BOTTOM, pady=10)&#10;&#10;        tk.Label(&#10;            thank_you_frame,&#10;            text=&quot;Thank you for your participation!&quot;,&#10;            font=(&quot;Arial&quot;, 18, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='green'&#10;        ).pack()&#10;&#10;    def calculate_results(self):&#10;        &quot;&quot;&quot;Calculate results from the CSV file&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return None&#10;&#10;            # Find the CSV file for this session&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if not csv_files:&#10;                print(&quot;No CSV file found&quot;)&#10;                return None&#10;&#10;            csv_files.sort()&#10;            latest_csv = os.path.join(data_dir, csv_files[-1])&#10;&#10;            print(f&quot;Calculating results from: {latest_csv}&quot;)&#10;&#10;            # Read the CSV file&#10;            df = pd.read_csv(latest_csv)&#10;&#10;            # Initialize counters&#10;            first_correct = 0&#10;            first_total = 0&#10;            second_correct = 0&#10;            second_total = 0&#10;&#10;            first_details = []&#10;            second_details = []&#10;&#10;            # Process each row&#10;            for _, row in df.iterrows():&#10;                ice_word = str(row.get('ice', '')).strip().lower()&#10;                eng_word = str(row.get('eng', '')).strip().lower()&#10;                answer_1 = str(row.get('answ_1', '')).strip().lower()&#10;                answer_2 = str(row.get('answ_2', '')).strip().lower()&#10;&#10;                # Check first test answer&#10;                if answer_1:&#10;                    first_total += 1&#10;                    is_correct = (answer_1 == eng_word)&#10;                    if is_correct:&#10;                        first_correct += 1&#10;                    first_details.append({&#10;                        'ice': row.get('ice', ''),&#10;                        'eng': row.get('eng', ''),&#10;                        'answer': row.get('answ_1', ''),&#10;                        'correct': is_correct&#10;                    })&#10;&#10;                # Check second test answer&#10;                if answer_2:&#10;                    second_total += 1&#10;                    is_correct = (answer_2 == eng_word)&#10;                    if is_correct:&#10;                        second_correct += 1&#10;                    second_details.append({&#10;                        'ice': row.get('ice', ''),&#10;                        'eng': row.get('eng', ''),&#10;                        'answer': row.get('answ_2', ''),&#10;                        'correct': is_correct&#10;                    })&#10;&#10;            # Calculate percentages&#10;            first_percentage = (first_correct / first_total * 100) if first_total &gt; 0 else 0&#10;            second_percentage = (second_correct / second_total * 100) if second_total &gt; 0 else 0&#10;            total_correct = first_correct + second_correct&#10;            total_answered = first_total + second_total&#10;            overall_percentage = (total_correct / total_answered * 100) if total_answered &gt; 0 else 0&#10;&#10;            results = {&#10;                'first_correct': first_correct,&#10;                'first_total': first_total,&#10;                'first_percentage': first_percentage,&#10;                'second_correct': second_correct,&#10;                'second_total': second_total,&#10;                'second_percentage': second_percentage,&#10;                'total_correct': total_correct,&#10;                'total_answered': total_answered,&#10;                'overall_percentage': overall_percentage,&#10;                'first_details': first_details,&#10;                'second_details': second_details,&#10;                'csv_file': latest_csv&#10;            }&#10;&#10;            print(f&quot;Results calculated:&quot;)&#10;            print(f&quot;  First Test: {first_correct}/{first_total} ({first_percentage:.1f}%)&quot;)&#10;            print(f&quot;  Second Test: {second_correct}/{second_total} ({second_percentage:.1f}%)&quot;)&#10;            print(f&quot;  Overall: {total_correct}/{total_answered} ({overall_percentage:.1f}%)&quot;)&#10;&#10;            return results&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error calculating results: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return None&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the first countdown timer reaches zero - compatibility method&quot;&quot;&quot;&#10;        self.on_first_timer_finished()&#10;&#10;    def show_break_screen(self):&#10;        &quot;&quot;&quot;Display the break screen with dummy text&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main frame&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Title&#10;        title_label = tk.Label(&#10;            main_frame,&#10;            text=&quot;Break Time&quot;,&#10;            font=(&quot;Arial&quot;, 32, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 30))&#10;&#10;        # Create text frame with scrollbar&#10;        text_frame = tk.Frame(main_frame, bg='white')&#10;        text_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Text widget with scrollbar&#10;        text_widget = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            padx=20,&#10;            pady=20&#10;        )&#10;&#10;        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=text_widget.yview)&#10;        text_widget.configure(yscrollcommand=scrollbar.set)&#10;&#10;        # Pack text widget and scrollbar&#10;        text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Break screen dummy text&#10;        break_text = &quot;&quot;&quot;&#10;        Great job completing the first test!&#10;&#10;        You have now finished the first memory test. Take a moment to relax and rest your mind.&#10;&#10;        During this break, you can:&#10;        • Take a deep breath and relax&#10;        • Stretch if you need to&#10;        • Clear your mind from the previous task&#10;&#10;        The next part of the experiment will begin when you click the &quot;Next&quot; button below.&#10;&#10;        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&#10;&#10;        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&#10;&#10;        When you're ready to continue with the next phase of the experiment, please click the &quot;Next&quot; button.&#10;&#10;        Thank you for your continued participation in this cognitive science research!&#10;        &quot;&quot;&quot;&#10;&#10;        # Insert break text&#10;        text_widget.insert(tk.END, break_text.strip())&#10;        text_widget.config(state=tk.DISABLED)  # Make text read-only&#10;&#10;        # Next button in bottom right corner&#10;        button_frame = tk.Frame(main_frame, bg='white')&#10;        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 0))&#10;&#10;        next_button = tk.Button(&#10;            button_frame,&#10;            text=&quot;Next&quot;,&#10;            font=(&quot;Arial&quot;, 14),&#10;            bg='lightgreen',&#10;            command=self.on_break_next_clicked,&#10;            width=10,&#10;            height=2&#10;        )&#10;        next_button.pack(side=tk.RIGHT)&#10;&#10;    def on_break_next_clicked(self):&#10;        &quot;&quot;&quot;Handle next button click from break screen&quot;&quot;&quot;&#10;        print(&quot;Break completed, moving to second memorizing screen&quot;)&#10;        # Show second memorizing screen before the second test&#10;        self.show_second_memorizing_screen()&#10;&#10;    def show_second_memorizing_screen(self):&#10;        &quot;&quot;&quot;Display the second memorizing screen with word pairs before the second test&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Create main container&#10;        main_container = tk.Frame(self.root, bg='white')&#10;        main_container.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)&#10;&#10;        # Title (smaller)&#10;        title_label = tk.Label(&#10;            main_container,&#10;            text=&quot;Memorizing Screen - Round 2&quot;,&#10;            font=(&quot;Arial&quot;, 16, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        title_label.pack(pady=(0, 5))&#10;&#10;        # Create horizontal layout: word list on left, info panel on right&#10;        content_frame = tk.Frame(main_container, bg='white')&#10;        content_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left side: Word pairs list (no scrollbar needed)&#10;        list_frame = tk.Frame(content_frame, bg='white', relief=tk.RAISED, bd=1)&#10;        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))&#10;&#10;        # List title (smaller)&#10;        list_title = tk.Label(&#10;            list_frame,&#10;            text=&quot;Word Pairs&quot;,&#10;            font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        list_title.pack(pady=3)&#10;&#10;        # Create container frame for word list (no canvas/scrollbar)&#10;        words_container = tk.Frame(list_frame, bg='white')&#10;        words_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)&#10;&#10;        # Display word pairs as a compact list&#10;        for index in range(len(self.second_phase_words)):&#10;            row = self.second_phase_words.iloc[index]&#10;            ice_word = row.get('ice', '')&#10;            eng_word = row.get('eng', '')&#10;&#10;            # Create frame for each word pair (minimal padding)&#10;            pair_frame = tk.Frame(&#10;                words_container,&#10;                bg='white',&#10;                relief=tk.FLAT,&#10;                bd=0,&#10;                padx=1,&#10;                pady=0&#10;            )&#10;            pair_frame.pack(fill=tk.X, padx=1, pady=0)&#10;&#10;            # Number label (smaller)&#10;            number_label = tk.Label(&#10;                pair_frame,&#10;                text=f&quot;{index + 1}.&quot;,&#10;                font=(&quot;Arial&quot;, 9, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                width=2,&#10;                anchor='w'&#10;            )&#10;            number_label.pack(side=tk.LEFT, padx=(0, 2))&#10;&#10;            # Icelandic word (no background color)&#10;            ice_label = tk.Label(&#10;                pair_frame,&#10;                text=ice_word,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=2,&#10;                pady=0,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            ice_label.pack(side=tk.LEFT, padx=1)&#10;&#10;            # Arrow (smaller)&#10;            arrow_label = tk.Label(&#10;                pair_frame,&#10;                text=&quot;→&quot;,&#10;                font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                bg='white',&#10;                fg='black'&#10;            )&#10;            arrow_label.pack(side=tk.LEFT, padx=1)&#10;&#10;            # English word (no background color)&#10;            eng_label = tk.Label(&#10;                pair_frame,&#10;                text=eng_word,&#10;                font=(&quot;Arial&quot;, 10),&#10;                bg='white',&#10;                fg='black',&#10;                relief=tk.FLAT,&#10;                padx=2,&#10;                pady=0,&#10;                width=18,&#10;                anchor='w'&#10;            )&#10;            eng_label.pack(side=tk.LEFT, padx=1)&#10;&#10;        # Right side: Information panel and timer (more compact)&#10;        info_panel = tk.Frame(content_frame, bg='lightgray', width=250, relief=tk.RAISED, bd=1)&#10;        info_panel.pack(side=tk.RIGHT, fill=tk.Y)&#10;        info_panel.pack_propagate(False)  # Maintain fixed width&#10;&#10;        # Timer display&#10;        timer_frame = tk.Frame(info_panel, bg='lightgray')&#10;        timer_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        timer_label = tk.Label(&#10;            timer_frame,&#10;            text=&quot;Time Remaining:&quot;,&#10;            font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(&#10;            timer_frame,&#10;            text=&quot;08:00&quot;,&#10;            font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='red'&#10;        )&#10;        self.timer_display.pack()&#10;&#10;        # Information text area&#10;        info_title = tk.Label(&#10;            info_panel,&#10;            text=&quot;Instructions&quot;,&#10;            font=(&quot;Arial&quot;, 11, &quot;bold&quot;),&#10;            bg='lightgray',&#10;            fg='black'&#10;        )&#10;        info_title.pack(pady=(5, 3))&#10;&#10;        # Create scrollable text widget for information&#10;        text_frame = tk.Frame(info_panel, bg='lightgray')&#10;        text_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))&#10;&#10;        info_text = tk.Text(&#10;            text_frame,&#10;            font=(&quot;Arial&quot;, 9),&#10;            bg='white',&#10;            fg='black',&#10;            wrap=tk.WORD,&#10;            height=8&#10;        )&#10;&#10;        info_scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=info_text.yview)&#10;        info_text.configure(yscrollcommand=info_scrollbar.set)&#10;&#10;        info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)&#10;        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)&#10;&#10;        # Add instruction text for second memorization session&#10;        instruction_text = &quot;&quot;&quot;&#10;        Review the word pairs again. You have 8 minutes to refresh your memory of the associations between the Icelandic and English words.&#10;&#10;        After the time expires, you will be tested again on your remembrance of these word pairs. The questions will be presented in a different order.&#10;&#10;        Good luck with your second memorization session!&#10;        &quot;&quot;&quot;&#10;&#10;        info_text.insert(tk.END, instruction_text.strip())&#10;        info_text.config(state=tk.DISABLED)&#10;&#10;        # Add a Next button for testing purposes&#10;        next_button_frame = tk.Frame(info_panel, bg='lightgray')&#10;        next_button_frame.pack(fill=tk.X, padx=5, pady=5)&#10;&#10;        next_button = tk.Button(&#10;            next_button_frame,&#10;            text=&quot;Next (Testing)&quot;,&#10;            font=(&quot;Arial&quot;, 10),&#10;            bg='orange',&#10;            fg='white',&#10;            command=self.on_second_timer_finished,&#10;            width=15,&#10;            height=2&#10;        )&#10;        next_button.pack()&#10;&#10;        # Start the countdown timer for second memorization&#10;        self.start_second_countdown_timer()&#10;&#10;def main():&#10;    root = tk.Tk()&#10;    app = ExperimentApp(root)&#10;    root.mainloop()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>