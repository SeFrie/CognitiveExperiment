<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/second_test_screen.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/second_test_screen.py" />
              <option name="originalContent" value="import tkinter as tk&#10;import pandas as pd&#10;import os&#10;import random&#10;&#10;&#10;class SecondTestScreen:&#10;    def __init__(self, root, word_data, unique_id, completion_callback=None):&#10;        &quot;&quot;&quot;&#10;        Initialize the second test screen with randomized question order&#10;&#10;        Args:&#10;            root: The tkinter root window&#10;            word_data: DataFrame with word pairs&#10;            unique_id: Unique session identifier&#10;            completion_callback: Function to call when test is completed&#10;        &quot;&quot;&quot;&#10;        self.root = root&#10;        self.word_data = word_data&#10;        self.unique_id = unique_id&#10;        self.completion_callback = completion_callback&#10;&#10;        # Create randomized question order&#10;        self.question_indices = list(range(len(self.word_data)))&#10;        random.shuffle(self.question_indices)  # Randomize the order&#10;&#10;        # Initialize test variables&#10;        self.current_question = 0&#10;        self.answers = {}  # Store answers by word_id (not question index)&#10;        self.total_questions = min(20, len(self.word_data))&#10;&#10;        # Timer variables&#10;        self.time_remaining = 3 * 60  # 3 minutes in seconds&#10;        self.timer_display = None&#10;&#10;        # UI components&#10;        self.question_cards = []&#10;        self.card_frames = []&#10;        self.question_label = None&#10;        self.answer_entry = None&#10;        self.prev_button = None&#10;        self.next_button = None&#10;&#10;        print(f&quot;Second test created with randomized order: {self.question_indices[:5]}...&quot;)&#10;&#10;        self.setup_ui()&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Setup the second test screen user interface&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Main container&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Timer in upper left corner&#10;        timer_frame = tk.Frame(main_frame, bg='white')&#10;        timer_frame.pack(anchor='nw', pady=(0, 10))&#10;&#10;        timer_label = tk.Label(timer_frame, text=&quot;Time Remaining:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(timer_frame, text=&quot;03:00&quot;, font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;                                    bg='white', fg='red')&#10;        self.timer_display.pack()&#10;&#10;        # Title&#10;        title = tk.Label(main_frame, text=&quot;Second Test Screen&quot;, font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white')&#10;        title.pack(pady=10)&#10;&#10;        # Create two-column layout&#10;        content_container = tk.Frame(main_frame, bg='white')&#10;        content_container.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left column: Question and navigation&#10;        left_frame = tk.Frame(content_container, bg='white')&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 20))&#10;&#10;        # Right column: Question cards&#10;        right_frame = tk.Frame(content_container, bg='white', width=250)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y)&#10;        right_frame.pack_propagate(False)&#10;&#10;        # Question cards in right frame&#10;        cards_title = tk.Label(right_frame, text=&quot;Questions&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        cards_title.pack(pady=(0, 10))&#10;&#10;        # Create 4x5 grid of question cards&#10;        grid_frame = tk.Frame(right_frame, bg='white')&#10;        grid_frame.pack()&#10;&#10;        self.question_cards = []&#10;        self.card_frames = []&#10;        for row in range(4):&#10;            for col in range(5):&#10;                num = row * 5 + col + 1&#10;                if num &lt;= self.total_questions:&#10;                    # Create a frame for the border (this will show the red/green color)&#10;                    border_frame = tk.Frame(grid_frame, bg='red', bd=0)  # Start with red (unanswered)&#10;                    border_frame.grid(row=row, column=col, padx=2, pady=2)&#10;&#10;                    # Create the card inside the border frame&#10;                    card = tk.Label(border_frame, text=str(num), font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                                  bg='white', width=4, height=2, relief=tk.FLAT)&#10;                    card.pack(padx=3, pady=3)  # This creates the border effect&#10;                    card.bind('&lt;Button-1&gt;', lambda e, q=num-1: self.jump_to_question(q))&#10;&#10;                    self.question_cards.append(card)&#10;                    self.card_frames.append(border_frame)&#10;&#10;        # Question display in left frame&#10;        self.question_label = tk.Label(left_frame, text=&quot;&quot;, font=(&quot;Arial&quot;, 32, &quot;bold&quot;), bg='white')&#10;        self.question_label.pack(expand=True)&#10;&#10;        # Navigation area - bottom of left frame&#10;        nav_frame = tk.Frame(left_frame, bg='white')&#10;        nav_frame.pack(side=tk.BOTTOM, pady=20)&#10;&#10;        # Input instruction&#10;        instruction = tk.Label(nav_frame, text=&quot;Enter English translation:&quot;, font=(&quot;Arial&quot;, 14), bg='white')&#10;        instruction.pack(pady=(0, 10))&#10;&#10;        # Button and input layout using grid for reliable positioning&#10;        button_input_frame = tk.Frame(nav_frame, bg='white')&#10;        button_input_frame.pack()&#10;&#10;        # Previous button (left)&#10;        self.prev_button = tk.Button(button_input_frame, text=&quot;Previous&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.previous_question, width=10, height=2)&#10;        self.prev_button.grid(row=0, column=0, padx=10, pady=5)&#10;&#10;        # Input field (center)&#10;        self.answer_entry = tk.Entry(button_input_frame, font=(&quot;Arial&quot;, 16), width=25, justify='center')&#10;        self.answer_entry.grid(row=0, column=1, padx=10, pady=5)&#10;        self.answer_entry.bind('&lt;KeyRelease&gt;', self.on_answer_changed)&#10;        self.answer_entry.focus()&#10;&#10;        # Next button (right)&#10;        self.next_button = tk.Button(button_input_frame, text=&quot;Next&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.next_question, width=10, height=2)&#10;        self.next_button.grid(row=0, column=2, padx=10, pady=5)&#10;&#10;        # Finish Test button for easy testing&#10;        finish_frame = tk.Frame(nav_frame, bg='white')&#10;        finish_frame.pack(pady=(10, 0))&#10;&#10;        self.finish_test_button = tk.Button(finish_frame, text=&quot;Finish Second Test (Testing)&quot;,&#10;                                          font=(&quot;Arial&quot;, 12), bg='purple', fg='white',&#10;                                          command=self.finish_test, width=25, height=2)&#10;        self.finish_test_button.pack()&#10;&#10;        # Start with first question&#10;        self.display_current_question()&#10;&#10;        # Start the 3-minute countdown timer&#10;        self.start_timer()&#10;&#10;    def get_current_word_id(self):&#10;        &quot;&quot;&quot;Get the word_id for the current randomized question&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.question_indices):&#10;            randomized_index = self.question_indices[self.current_question]&#10;            if randomized_index &lt; len(self.word_data):&#10;                row = self.word_data.iloc[randomized_index]&#10;                return row.get('word_id', randomized_index + 1)&#10;        return None&#10;&#10;    def display_current_question(self):&#10;        &quot;&quot;&quot;Display the current question (in randomized order)&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.question_indices):&#10;            # Get the randomized question index&#10;            randomized_index = self.question_indices[self.current_question]&#10;&#10;            if randomized_index &lt; len(self.word_data):&#10;                row = self.word_data.iloc[randomized_index]&#10;                icelandic_word = row.get('ice', '')&#10;                word_id = row.get('word_id', randomized_index + 1)&#10;&#10;                self.question_label.config(text=icelandic_word)&#10;&#10;                # Show existing answer if any (stored by word_id)&#10;                existing_answer = self.answers.get(word_id, '')&#10;                self.answer_entry.delete(0, tk.END)&#10;                self.answer_entry.insert(0, existing_answer)&#10;&#10;                # Update card colors&#10;                self.update_all_cards()&#10;&#10;                # Update button states&#10;                self.prev_button.config(state='normal' if self.current_question &gt; 0 else 'disabled')&#10;                self.next_button.config(state='normal' if self.current_question &lt; self.total_questions - 1 else 'disabled')&#10;&#10;    def update_all_cards(self):&#10;        &quot;&quot;&quot;Update all question card colors based on answer status&quot;&quot;&quot;&#10;        for i in range(len(self.question_cards)):&#10;            card = self.question_cards[i]&#10;            border_frame = self.card_frames[i]&#10;&#10;            # Get the word_id for this card position&#10;            if i &lt; len(self.question_indices):&#10;                randomized_index = self.question_indices[i]&#10;                if randomized_index &lt; len(self.word_data):&#10;                    row = self.word_data.iloc[randomized_index]&#10;                    word_id = row.get('word_id', randomized_index + 1)&#10;&#10;                    if word_id in self.answers and self.answers[word_id].strip():&#10;                        # Answered - green border&#10;                        border_frame.config(bg='green')&#10;                    else:&#10;                        # Unanswered - red border&#10;                        border_frame.config(bg='red')&#10;&#10;            # Current question highlight&#10;            if i == self.current_question:&#10;                card.config(bg='lightblue')&#10;            else:&#10;                card.config(bg='white')&#10;&#10;    def on_answer_changed(self, event=None):&#10;        &quot;&quot;&quot;Handle answer change - save on every keystroke using word_id&quot;&quot;&quot;&#10;        answer = self.answer_entry.get().strip()&#10;        word_id = self.get_current_word_id()&#10;        if word_id is not None:&#10;            self.answers[word_id] = answer&#10;            self.update_all_cards()&#10;&#10;    def previous_question(self):&#10;        &quot;&quot;&quot;Go to previous question&quot;&quot;&quot;&#10;        if self.current_question &gt; 0:&#10;            self.current_question -= 1&#10;            self.display_current_question()&#10;&#10;    def next_question(self):&#10;        &quot;&quot;&quot;Go to next question&quot;&quot;&quot;&#10;        if self.current_question &lt; self.total_questions - 1:&#10;            self.current_question += 1&#10;            self.display_current_question()&#10;&#10;    def jump_to_question(self, question_index):&#10;        &quot;&quot;&quot;Jump to a specific question when card is clicked&quot;&quot;&quot;&#10;        if 0 &lt;= question_index &lt; self.total_questions:&#10;            self.current_question = question_index&#10;            self.display_current_question()&#10;&#10;    def start_timer(self):&#10;        &quot;&quot;&quot;Start the 3-minute countdown timer&quot;&quot;&quot;&#10;        self.update_timer()&#10;&#10;    def update_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display&quot;&quot;&quot;&#10;        if self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if self.timer_display:&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 30:  # Last 30 seconds&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='orange')&#10;                else:&#10;                    self.timer_display.config(fg='red')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_timer)&#10;        else:&#10;            # Time's up!&#10;            if self.timer_display:&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_timer_finished()&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the 3-minute timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Second test time finished!&quot;)&#10;        # Save answers and complete the test&#10;        self.save_answers_to_csv()&#10;        if self.completion_callback:&#10;            self.completion_callback(self.answers)&#10;&#10;    def finish_test(self):&#10;        &quot;&quot;&quot;Finish the test immediately (for testing purposes)&quot;&quot;&quot;&#10;        self.time_remaining = 0&#10;        self.update_timer()&#10;&#10;    def save_answers_to_csv(self):&#10;        &quot;&quot;&quot;Save the answers to the CSV file in answ_2 column using word_id&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return&#10;&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if csv_files:&#10;                csv_files.sort()&#10;                latest_csv = os.path.join(data_dir, csv_files[-1])&#10;                df = pd.read_csv(latest_csv)&#10;&#10;                # Update the answ_2 column with answers using word_id matching&#10;                for word_id, answer in self.answers.items():&#10;                    # Find the row with matching word_id&#10;                    matching_rows = df[df['word_id'] == word_id]&#10;                    if not matching_rows.empty:&#10;                        row_index = matching_rows.index[0]&#10;                        df.loc[row_index, 'answ_2'] = answer&#10;                        print(f&quot;Saved answer for word_id {word_id}: '{answer}'&quot;)&#10;&#10;                df.to_csv(latest_csv, index=False)&#10;                print(f&quot;Second test answers saved to {latest_csv}&quot;)&#10;            else:&#10;                print(&quot;No CSV file found to update&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving second test answers: {e}&quot;)&#10;&#10;    def get_answers(self):&#10;        &quot;&quot;&quot;Get the current answers dictionary&quot;&quot;&quot;&#10;        return self.answers.copy()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;import pandas as pd&#10;import os&#10;import random&#10;&#10;&#10;class SecondTestScreen:&#10;    def __init__(self, root, word_data, unique_id, completion_callback=None):&#10;        &quot;&quot;&quot;&#10;        Initialize the second test screen with randomized question order&#10;&#10;        Args:&#10;            root: The tkinter root window&#10;            word_data: DataFrame with word pairs&#10;            unique_id: Unique session identifier&#10;            completion_callback: Function to call when test is completed&#10;        &quot;&quot;&quot;&#10;        self.root = root&#10;        self.word_data = word_data&#10;        self.unique_id = unique_id&#10;        self.completion_callback = completion_callback&#10;&#10;        # Create randomized question order&#10;        self.question_indices = list(range(len(self.word_data)))&#10;        random.shuffle(self.question_indices)  # Randomize the order&#10;&#10;        # Initialize test variables&#10;        self.current_question = 0&#10;        self.answers = {}  # Store answers by word_id (not question index)&#10;        self.total_questions = min(25, len(self.word_data))  # Changed from 20 to 25&#10;&#10;        # Timer variables&#10;        self.time_remaining = 3 * 60  # 3 minutes in seconds&#10;        self.timer_display = None&#10;&#10;        # UI components&#10;        self.question_cards = []&#10;        self.card_frames = []&#10;        self.question_label = None&#10;        self.answer_entry = None&#10;        self.prev_button = None&#10;        self.next_button = None&#10;&#10;        print(f&quot;Second test created with randomized order: {self.question_indices[:5]}...&quot;)&#10;&#10;        self.setup_ui()&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Setup the second test screen user interface&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Main container&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Timer in upper left corner&#10;        timer_frame = tk.Frame(main_frame, bg='white')&#10;        timer_frame.pack(anchor='nw', pady=(0, 10))&#10;&#10;        timer_label = tk.Label(timer_frame, text=&quot;Time Remaining:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(timer_frame, text=&quot;03:00&quot;, font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;                                    bg='white', fg='red')&#10;        self.timer_display.pack()&#10;&#10;        # Title&#10;        title = tk.Label(main_frame, text=&quot;Second Test Screen&quot;, font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white')&#10;        title.pack(pady=10)&#10;&#10;        # Create two-column layout&#10;        content_container = tk.Frame(main_frame, bg='white')&#10;        content_container.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left column: Question and navigation&#10;        left_frame = tk.Frame(content_container, bg='white')&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 20))&#10;&#10;        # Right column: Question cards&#10;        right_frame = tk.Frame(content_container, bg='white', width=250)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y)&#10;        right_frame.pack_propagate(False)&#10;&#10;        # Question cards in right frame&#10;        cards_title = tk.Label(right_frame, text=&quot;Questions&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        cards_title.pack(pady=(0, 10))&#10;&#10;        # Create 5x5 grid of question cards&#10;        grid_frame = tk.Frame(right_frame, bg='white')&#10;        grid_frame.pack()&#10;&#10;        self.question_cards = []&#10;        self.card_frames = []&#10;        for row in range(5):  # Changed from 4 to 5&#10;            for col in range(5):&#10;                num = row * 5 + col + 1&#10;                if num &lt;= self.total_questions:&#10;                    # Create a frame for the border (this will show the red/green color)&#10;                    border_frame = tk.Frame(grid_frame, bg='red', bd=0)  # Start with red (unanswered)&#10;                    border_frame.grid(row=row, column=col, padx=2, pady=2)&#10;&#10;                    # Create the card inside the border frame&#10;                    card = tk.Label(border_frame, text=str(num), font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                                  bg='white', width=4, height=2, relief=tk.FLAT)&#10;                    card.pack(padx=3, pady=3)  # This creates the border effect&#10;                    card.bind('&lt;Button-1&gt;', lambda e, q=num-1: self.jump_to_question(q))&#10;&#10;                    self.question_cards.append(card)&#10;                    self.card_frames.append(border_frame)&#10;&#10;        # Question display in left frame&#10;        self.question_label = tk.Label(left_frame, text=&quot;&quot;, font=(&quot;Arial&quot;, 32, &quot;bold&quot;), bg='white')&#10;        self.question_label.pack(expand=True)&#10;&#10;        # Navigation area - bottom of left frame&#10;        nav_frame = tk.Frame(left_frame, bg='white')&#10;        nav_frame.pack(side=tk.BOTTOM, pady=20)&#10;&#10;        # Input instruction&#10;        instruction = tk.Label(nav_frame, text=&quot;Enter English translation:&quot;, font=(&quot;Arial&quot;, 14), bg='white')&#10;        instruction.pack(pady=(0, 10))&#10;&#10;        # Button and input layout using grid for reliable positioning&#10;        button_input_frame = tk.Frame(nav_frame, bg='white')&#10;        button_input_frame.pack()&#10;&#10;        # Previous button (left)&#10;        self.prev_button = tk.Button(button_input_frame, text=&quot;Previous&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.previous_question, width=10, height=2)&#10;        self.prev_button.grid(row=0, column=0, padx=10, pady=5)&#10;&#10;        # Input field (center)&#10;        self.answer_entry = tk.Entry(button_input_frame, font=(&quot;Arial&quot;, 16), width=25, justify='center')&#10;        self.answer_entry.grid(row=0, column=1, padx=10, pady=5)&#10;        self.answer_entry.bind('&lt;KeyRelease&gt;', self.on_answer_changed)&#10;        self.answer_entry.focus()&#10;&#10;        # Next button (right)&#10;        self.next_button = tk.Button(button_input_frame, text=&quot;Next&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.next_question, width=10, height=2)&#10;        self.next_button.grid(row=0, column=2, padx=10, pady=5)&#10;&#10;        # Finish Test button for easy testing&#10;        finish_frame = tk.Frame(nav_frame, bg='white')&#10;        finish_frame.pack(pady=(10, 0))&#10;&#10;        self.finish_test_button = tk.Button(finish_frame, text=&quot;Finish Second Test (Testing)&quot;,&#10;                                          font=(&quot;Arial&quot;, 12), bg='purple', fg='white',&#10;                                          command=self.finish_test, width=25, height=2)&#10;        self.finish_test_button.pack()&#10;&#10;        # Start with first question&#10;        self.display_current_question()&#10;&#10;        # Start the 3-minute countdown timer&#10;        self.start_timer()&#10;&#10;    def get_current_word_id(self):&#10;        &quot;&quot;&quot;Get the word_id for the current randomized question&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.question_indices):&#10;            randomized_index = self.question_indices[self.current_question]&#10;            if randomized_index &lt; len(self.word_data):&#10;                row = self.word_data.iloc[randomized_index]&#10;                return row.get('word_id', randomized_index + 1)&#10;        return None&#10;&#10;    def display_current_question(self):&#10;        &quot;&quot;&quot;Display the current question (in randomized order)&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.question_indices):&#10;            # Get the randomized question index&#10;            randomized_index = self.question_indices[self.current_question]&#10;&#10;            if randomized_index &lt; len(self.word_data):&#10;                row = self.word_data.iloc[randomized_index]&#10;                icelandic_word = row.get('ice', '')&#10;                word_id = row.get('word_id', randomized_index + 1)&#10;&#10;                self.question_label.config(text=icelandic_word)&#10;&#10;                # Show existing answer if any (stored by word_id)&#10;                existing_answer = self.answers.get(word_id, '')&#10;                self.answer_entry.delete(0, tk.END)&#10;                self.answer_entry.insert(0, existing_answer)&#10;&#10;                # Update card colors&#10;                self.update_all_cards()&#10;&#10;                # Update button states&#10;                self.prev_button.config(state='normal' if self.current_question &gt; 0 else 'disabled')&#10;                self.next_button.config(state='normal' if self.current_question &lt; self.total_questions - 1 else 'disabled')&#10;&#10;    def update_all_cards(self):&#10;        &quot;&quot;&quot;Update all question card colors based on answer status&quot;&quot;&quot;&#10;        for i in range(len(self.question_cards)):&#10;            card = self.question_cards[i]&#10;            border_frame = self.card_frames[i]&#10;&#10;            # Get the word_id for this card position&#10;            if i &lt; len(self.question_indices):&#10;                randomized_index = self.question_indices[i]&#10;                if randomized_index &lt; len(self.word_data):&#10;                    row = self.word_data.iloc[randomized_index]&#10;                    word_id = row.get('word_id', randomized_index + 1)&#10;&#10;                    if word_id in self.answers and self.answers[word_id].strip():&#10;                        # Answered - green border&#10;                        border_frame.config(bg='green')&#10;                    else:&#10;                        # Unanswered - red border&#10;                        border_frame.config(bg='red')&#10;&#10;            # Current question highlight&#10;            if i == self.current_question:&#10;                card.config(bg='lightblue')&#10;            else:&#10;                card.config(bg='white')&#10;&#10;    def on_answer_changed(self, event=None):&#10;        &quot;&quot;&quot;Handle answer change - save on every keystroke using word_id&quot;&quot;&quot;&#10;        answer = self.answer_entry.get().strip()&#10;        word_id = self.get_current_word_id()&#10;        if word_id is not None:&#10;            self.answers[word_id] = answer&#10;            self.update_all_cards()&#10;&#10;    def previous_question(self):&#10;        &quot;&quot;&quot;Go to previous question&quot;&quot;&quot;&#10;        if self.current_question &gt; 0:&#10;            self.current_question -= 1&#10;            self.display_current_question()&#10;&#10;    def next_question(self):&#10;        &quot;&quot;&quot;Go to next question&quot;&quot;&quot;&#10;        if self.current_question &lt; self.total_questions - 1:&#10;            self.current_question += 1&#10;            self.display_current_question()&#10;&#10;    def jump_to_question(self, question_index):&#10;        &quot;&quot;&quot;Jump to a specific question when card is clicked&quot;&quot;&quot;&#10;        if 0 &lt;= question_index &lt; self.total_questions:&#10;            self.current_question = question_index&#10;            self.display_current_question()&#10;&#10;    def start_timer(self):&#10;        &quot;&quot;&quot;Start the 3-minute countdown timer&quot;&quot;&quot;&#10;        self.update_timer()&#10;&#10;    def update_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display&quot;&quot;&quot;&#10;        if self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if self.timer_display:&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 30:  # Last 30 seconds&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='orange')&#10;                else:&#10;                    self.timer_display.config(fg='red')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_timer)&#10;        else:&#10;            # Time's up!&#10;            if self.timer_display:&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_timer_finished()&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the 3-minute timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Second test time finished!&quot;)&#10;        # Save answers and complete the test&#10;        self.save_answers_to_csv()&#10;        if self.completion_callback:&#10;            self.completion_callback(self.answers)&#10;&#10;    def finish_test(self):&#10;        &quot;&quot;&quot;Finish the test immediately (for testing purposes)&quot;&quot;&quot;&#10;        self.time_remaining = 0&#10;        self.update_timer()&#10;&#10;    def save_answers_to_csv(self):&#10;        &quot;&quot;&quot;Save the answers to the CSV file in answ_2 column using word_id&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return&#10;&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if csv_files:&#10;                csv_files.sort()&#10;                latest_csv = os.path.join(data_dir, csv_files[-1])&#10;                df = pd.read_csv(latest_csv)&#10;                &#10;                # Ensure word_id columns are the same type (int)&#10;                df['word_id'] = df['word_id'].astype(int)&#10;&#10;                print(f&quot;Saving {len(self.answers)} answers to CSV...&quot;)&#10;&#10;                # Update the answ_2 column with answers using word_id matching&#10;                for word_id, answer in self.answers.items():&#10;                    # Ensure word_id is int for matching&#10;                    word_id = int(word_id)&#10;                    &#10;                    # Find the row with matching word_id&#10;                    matching_rows = df[df['word_id'] == word_id]&#10;                    if not matching_rows.empty:&#10;                        row_index = matching_rows.index[0]&#10;                        df.loc[row_index, 'answ_2'] = answer&#10;                        print(f&quot;  Saved answer for word_id {word_id}: '{answer}'&quot;)&#10;                    else:&#10;                        print(f&quot;  WARNING: No matching row found for word_id {word_id}&quot;)&#10;&#10;                df.to_csv(latest_csv, index=False)&#10;                print(f&quot;âœ“ Second test answers saved to {latest_csv}&quot;)&#10;            else:&#10;                print(&quot;No CSV file found to update&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving second test answers: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def get_answers(self):&#10;        &quot;&quot;&quot;Get the current answers dictionary&quot;&quot;&quot;&#10;        return self.answers.copy()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test_screen.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test_screen.py" />
              <option name="originalContent" value="import tkinter as tk&#10;import pandas as pd&#10;import os&#10;&#10;&#10;class TestScreen:&#10;    def __init__(self, root, word_data, unique_id, completion_callback=None):&#10;        &quot;&quot;&quot;&#10;        Initialize the test screen&#10;&#10;        Args:&#10;            root: The tkinter root window&#10;            word_data: DataFrame with word pairs&#10;            unique_id: Unique session identifier&#10;            completion_callback: Function to call when test is completed&#10;        &quot;&quot;&quot;&#10;        self.root = root&#10;        self.word_data = word_data&#10;        self.unique_id = unique_id&#10;        self.completion_callback = completion_callback&#10;&#10;        # Initialize test variables&#10;        self.current_question = 0&#10;        self.answers = {}  # Store answers by question index&#10;        self.total_questions = min(20, len(self.word_data))&#10;&#10;        # Timer variables&#10;        self.time_remaining = 3 * 60  # 3 minutes in seconds&#10;        self.timer_display = None&#10;&#10;        # UI components&#10;        self.question_cards = []&#10;        self.card_frames = []  # Store the border frames&#10;        self.question_label = None&#10;        self.answer_entry = None&#10;        self.prev_button = None&#10;        self.next_button = None&#10;&#10;        self.setup_ui()&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Setup the test screen user interface&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Main container&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Timer in upper left corner&#10;        timer_frame = tk.Frame(main_frame, bg='white')&#10;        timer_frame.pack(anchor='nw', pady=(0, 10))&#10;&#10;        timer_label = tk.Label(timer_frame, text=&quot;Time Remaining:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(timer_frame, text=&quot;03:00&quot;, font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;                                    bg='white', fg='red')&#10;        self.timer_display.pack()&#10;&#10;        # Title&#10;        title = tk.Label(main_frame, text=&quot;Test Screen&quot;, font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white')&#10;        title.pack(pady=10)&#10;&#10;        # Create two-column layout&#10;        content_container = tk.Frame(main_frame, bg='white')&#10;        content_container.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left column: Question and navigation&#10;        left_frame = tk.Frame(content_container, bg='white')&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 20))&#10;&#10;        # Right column: Question cards&#10;        right_frame = tk.Frame(content_container, bg='white', width=250)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y)&#10;        right_frame.pack_propagate(False)&#10;&#10;        # Question cards in right frame&#10;        cards_title = tk.Label(right_frame, text=&quot;Questions&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        cards_title.pack(pady=(0, 10))&#10;&#10;        # Create 4x5 grid of question cards&#10;        grid_frame = tk.Frame(right_frame, bg='white')&#10;        grid_frame.pack()&#10;&#10;        self.question_cards = []&#10;        self.card_frames = []  # Store the border frames&#10;        for row in range(4):&#10;            for col in range(5):&#10;                num = row * 5 + col + 1&#10;                if num &lt;= self.total_questions:&#10;                    # Create a frame for the border (this will show the red/green color)&#10;                    border_frame = tk.Frame(grid_frame, bg='red', bd=0)  # Start with red (unanswered)&#10;                    border_frame.grid(row=row, column=col, padx=2, pady=2)&#10;&#10;                    # Create the card inside the border frame&#10;                    card = tk.Label(border_frame, text=str(num), font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                                  bg='white', width=4, height=2, relief=tk.FLAT)&#10;                    card.pack(padx=3, pady=3)  # This creates the border effect&#10;                    card.bind('&lt;Button-1&gt;', lambda e, q=num-1: self.jump_to_question(q))&#10;&#10;                    self.question_cards.append(card)&#10;                    self.card_frames.append(border_frame)&#10;&#10;        # Question display in left frame&#10;        self.question_label = tk.Label(left_frame, text=&quot;&quot;, font=(&quot;Arial&quot;, 32, &quot;bold&quot;), bg='white')&#10;        self.question_label.pack(expand=True)&#10;&#10;        # Navigation area - bottom of left frame&#10;        nav_frame = tk.Frame(left_frame, bg='white')&#10;        nav_frame.pack(side=tk.BOTTOM, pady=20)&#10;&#10;        # Input instruction&#10;        instruction = tk.Label(nav_frame, text=&quot;Enter English translation:&quot;, font=(&quot;Arial&quot;, 14), bg='white')&#10;        instruction.pack(pady=(0, 10))&#10;&#10;        # Button and input layout using grid for reliable positioning&#10;        button_input_frame = tk.Frame(nav_frame, bg='white')&#10;        button_input_frame.pack()&#10;&#10;        # Previous button (left)&#10;        self.prev_button = tk.Button(button_input_frame, text=&quot;Previous&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.previous_question, width=10, height=2)&#10;        self.prev_button.grid(row=0, column=0, padx=10, pady=5)&#10;&#10;        # Input field (center)&#10;        self.answer_entry = tk.Entry(button_input_frame, font=(&quot;Arial&quot;, 16), width=25, justify='center')&#10;        self.answer_entry.grid(row=0, column=1, padx=10, pady=5)&#10;        self.answer_entry.bind('&lt;KeyRelease&gt;', self.on_answer_changed)&#10;        self.answer_entry.focus()&#10;&#10;        # Next button (right)&#10;        self.next_button = tk.Button(button_input_frame, text=&quot;Next&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.next_question, width=10, height=2)&#10;        self.next_button.grid(row=0, column=2, padx=10, pady=5)&#10;&#10;        # Finish Test button for easy testing (below the navigation buttons)&#10;        finish_frame = tk.Frame(nav_frame, bg='white')&#10;        finish_frame.pack(pady=(10, 0))&#10;&#10;        self.finish_test_button = tk.Button(finish_frame, text=&quot;Finish Test (Testing)&quot;,&#10;                                          font=(&quot;Arial&quot;, 12), bg='orange', fg='white',&#10;                                          command=self.finish_test, width=20, height=2)&#10;        self.finish_test_button.pack()&#10;&#10;        # Start with first question&#10;        self.display_current_question()&#10;&#10;        # Start the 3-minute countdown timer&#10;        self.start_timer()&#10;&#10;    def start_timer(self):&#10;        &quot;&quot;&quot;Start the 3-minute countdown timer&quot;&quot;&quot;&#10;        self.update_timer()&#10;&#10;    def update_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display&quot;&quot;&quot;&#10;        if self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if self.timer_display:&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 30:  # Last 30 seconds&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='orange')&#10;                else:&#10;                    self.timer_display.config(fg='red')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_timer)&#10;        else:&#10;            # Time's up!&#10;            if self.timer_display:&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_timer_finished()&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the 3-minute timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Test time finished!&quot;)&#10;        # Save answers and complete the test&#10;        self.save_answers_to_csv()&#10;        if self.completion_callback:&#10;            self.completion_callback(self.answers)&#10;        else:&#10;            # Show time's up message&#10;            self.show_times_up_screen()&#10;&#10;    def show_times_up_screen(self):&#10;        &quot;&quot;&quot;Show the time's up completion screen&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        completion_frame = tk.Frame(self.root, bg='white')&#10;        completion_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        completion_label = tk.Label(&#10;            completion_frame,&#10;            text=&quot;Time's Up!\n\nTest Completed.\nThank you for your participation.&quot;,&#10;            font=(&quot;Arial&quot;, 24, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        completion_label.pack(expand=True)&#10;&#10;    def display_current_question(self):&#10;        &quot;&quot;&quot;Display the current question&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.word_data):&#10;            row = self.word_data.iloc[self.current_question]&#10;            icelandic_word = row.get('ice', '')&#10;            self.question_label.config(text=icelandic_word)&#10;&#10;            # Show existing answer&#10;            existing_answer = self.answers.get(self.current_question, '')&#10;            self.answer_entry.delete(0, tk.END)&#10;            self.answer_entry.insert(0, existing_answer)&#10;&#10;            # Update card colors&#10;            self.update_all_cards()&#10;&#10;            # Update button states&#10;            self.prev_button.config(state='normal' if self.current_question &gt; 0 else 'disabled')&#10;            self.next_button.config(state='normal' if self.current_question &lt; self.total_questions - 1 else 'disabled')&#10;&#10;    def update_all_cards(self):&#10;        &quot;&quot;&quot;Update all question card colors based on answer status&quot;&quot;&quot;&#10;        for i in range(len(self.question_cards)):&#10;            card = self.question_cards[i]&#10;            border_frame = self.card_frames[i]&#10;            if i in self.answers and self.answers[i].strip():&#10;                # Answered - green border&#10;                border_frame.config(bg='green')&#10;            else:&#10;                # Unanswered - red border&#10;                border_frame.config(bg='red')&#10;&#10;            # Current question highlight&#10;            if i == self.current_question:&#10;                card.config(bg='lightblue')&#10;            else:&#10;                card.config(bg='white')&#10;&#10;    def on_answer_changed(self, event=None):&#10;        &quot;&quot;&quot;Handle answer change - save on every keystroke&quot;&quot;&quot;&#10;        answer = self.answer_entry.get().strip()&#10;        self.answers[self.current_question] = answer&#10;        self.update_all_cards()&#10;&#10;    def previous_question(self):&#10;        &quot;&quot;&quot;Go to previous question&quot;&quot;&quot;&#10;        if self.current_question &gt; 0:&#10;            self.current_question -= 1&#10;            self.display_current_question()&#10;&#10;    def next_question(self):&#10;        &quot;&quot;&quot;Go to next question&quot;&quot;&quot;&#10;        if self.current_question &lt; self.total_questions - 1:&#10;            self.current_question += 1&#10;            self.display_current_question()&#10;&#10;    def jump_to_question(self, question_index):&#10;        &quot;&quot;&quot;Jump to a specific question when card is clicked&quot;&quot;&quot;&#10;        if 0 &lt;= question_index &lt; self.total_questions:&#10;            self.current_question = question_index&#10;            self.display_current_question()&#10;&#10;    def save_answers_to_csv(self):&#10;        &quot;&quot;&quot;Save the answers to the CSV file in answ_1 column&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return&#10;&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if csv_files:&#10;                csv_files.sort()&#10;                latest_csv = os.path.join(data_dir, csv_files[-1])&#10;                df = pd.read_csv(latest_csv)&#10;&#10;                for question_index, answer in self.answers.items():&#10;                    if question_index &lt; len(df):&#10;                        df.loc[question_index, 'answ_1'] = answer&#10;&#10;                df.to_csv(latest_csv, index=False)&#10;                print(f&quot;Answers saved to {latest_csv}&quot;)&#10;            else:&#10;                print(&quot;No CSV file found to update&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving answers: {e}&quot;)&#10;&#10;    def get_answers(self):&#10;        &quot;&quot;&quot;Get the current answers dictionary&quot;&quot;&quot;&#10;        return self.answers.copy()&#10;&#10;    def finish_test(self):&#10;        &quot;&quot;&quot;Finish the test immediately (for testing purposes)&quot;&quot;&quot;&#10;        self.time_remaining = 0&#10;        self.update_timer()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;import pandas as pd&#10;import os&#10;&#10;&#10;class TestScreen:&#10;    def __init__(self, root, word_data, unique_id, completion_callback=None):&#10;        &quot;&quot;&quot;&#10;        Initialize the test screen&#10;&#10;        Args:&#10;            root: The tkinter root window&#10;            word_data: DataFrame with word pairs&#10;            unique_id: Unique session identifier&#10;            completion_callback: Function to call when test is completed&#10;        &quot;&quot;&quot;&#10;        self.root = root&#10;        self.word_data = word_data&#10;        self.unique_id = unique_id&#10;        self.completion_callback = completion_callback&#10;&#10;        # Initialize test variables&#10;        self.current_question = 0&#10;        self.answers = {}  # Store answers by question index&#10;        self.total_questions = min(25, len(self.word_data))  # Changed from 20 to 25&#10;&#10;        # Timer variables&#10;        self.time_remaining = 3 * 60  # 3 minutes in seconds&#10;        self.timer_display = None&#10;&#10;        # UI components&#10;        self.question_cards = []&#10;        self.card_frames = []  # Store the border frames&#10;        self.question_label = None&#10;        self.answer_entry = None&#10;        self.prev_button = None&#10;        self.next_button = None&#10;&#10;        self.setup_ui()&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Setup the test screen user interface&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        # Main container&#10;        main_frame = tk.Frame(self.root, bg='white')&#10;        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)&#10;&#10;        # Timer in upper left corner&#10;        timer_frame = tk.Frame(main_frame, bg='white')&#10;        timer_frame.pack(anchor='nw', pady=(0, 10))&#10;&#10;        timer_label = tk.Label(timer_frame, text=&quot;Time Remaining:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        timer_label.pack()&#10;&#10;        self.timer_display = tk.Label(timer_frame, text=&quot;03:00&quot;, font=(&quot;Arial&quot;, 20, &quot;bold&quot;),&#10;                                    bg='white', fg='red')&#10;        self.timer_display.pack()&#10;&#10;        # Title&#10;        title = tk.Label(main_frame, text=&quot;Test Screen&quot;, font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white')&#10;        title.pack(pady=10)&#10;&#10;        # Create two-column layout&#10;        content_container = tk.Frame(main_frame, bg='white')&#10;        content_container.pack(fill=tk.BOTH, expand=True)&#10;&#10;        # Left column: Question and navigation&#10;        left_frame = tk.Frame(content_container, bg='white')&#10;        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 20))&#10;&#10;        # Right column: Question cards&#10;        right_frame = tk.Frame(content_container, bg='white', width=250)&#10;        right_frame.pack(side=tk.RIGHT, fill=tk.Y)&#10;        right_frame.pack_propagate(False)&#10;&#10;        # Question cards in right frame&#10;        cards_title = tk.Label(right_frame, text=&quot;Questions&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='white')&#10;        cards_title.pack(pady=(0, 10))&#10;&#10;        # Create 5x5 grid of question cards&#10;        grid_frame = tk.Frame(right_frame, bg='white')&#10;        grid_frame.pack()&#10;&#10;        self.question_cards = []&#10;        self.card_frames = []  # Store the border frames&#10;        for row in range(5):  # Changed from 4 to 5&#10;            for col in range(5):&#10;                num = row * 5 + col + 1&#10;                if num &lt;= self.total_questions:&#10;                    # Create a frame for the border (this will show the red/green color)&#10;                    border_frame = tk.Frame(grid_frame, bg='red', bd=0)  # Start with red (unanswered)&#10;                    border_frame.grid(row=row, column=col, padx=2, pady=2)&#10;&#10;                    # Create the card inside the border frame&#10;                    card = tk.Label(border_frame, text=str(num), font=(&quot;Arial&quot;, 10, &quot;bold&quot;),&#10;                                  bg='white', width=4, height=2, relief=tk.FLAT)&#10;                    card.pack(padx=3, pady=3)  # This creates the border effect&#10;                    card.bind('&lt;Button-1&gt;', lambda e, q=num-1: self.jump_to_question(q))&#10;&#10;                    self.question_cards.append(card)&#10;                    self.card_frames.append(border_frame)&#10;&#10;        # Question display in left frame&#10;        self.question_label = tk.Label(left_frame, text=&quot;&quot;, font=(&quot;Arial&quot;, 32, &quot;bold&quot;), bg='white')&#10;        self.question_label.pack(expand=True)&#10;&#10;        # Navigation area - bottom of left frame&#10;        nav_frame = tk.Frame(left_frame, bg='white')&#10;        nav_frame.pack(side=tk.BOTTOM, pady=20)&#10;&#10;        # Input instruction&#10;        instruction = tk.Label(nav_frame, text=&quot;Enter English translation:&quot;, font=(&quot;Arial&quot;, 14), bg='white')&#10;        instruction.pack(pady=(0, 10))&#10;&#10;        # Button and input layout using grid for reliable positioning&#10;        button_input_frame = tk.Frame(nav_frame, bg='white')&#10;        button_input_frame.pack()&#10;&#10;        # Previous button (left)&#10;        self.prev_button = tk.Button(button_input_frame, text=&quot;Previous&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.previous_question, width=10, height=2)&#10;        self.prev_button.grid(row=0, column=0, padx=10, pady=5)&#10;&#10;        # Input field (center)&#10;        self.answer_entry = tk.Entry(button_input_frame, font=(&quot;Arial&quot;, 16), width=25, justify='center')&#10;        self.answer_entry.grid(row=0, column=1, padx=10, pady=5)&#10;        self.answer_entry.bind('&lt;KeyRelease&gt;', self.on_answer_changed)&#10;        self.answer_entry.focus()&#10;&#10;        # Next button (right)&#10;        self.next_button = tk.Button(button_input_frame, text=&quot;Next&quot;, font=(&quot;Arial&quot;, 12),&#10;                                   bg='lightgray', command=self.next_question, width=10, height=2)&#10;        self.next_button.grid(row=0, column=2, padx=10, pady=5)&#10;&#10;        # Finish Test button for easy testing (below the navigation buttons)&#10;        finish_frame = tk.Frame(nav_frame, bg='white')&#10;        finish_frame.pack(pady=(10, 0))&#10;&#10;        self.finish_test_button = tk.Button(finish_frame, text=&quot;Finish Test (Testing)&quot;,&#10;                                          font=(&quot;Arial&quot;, 12), bg='orange', fg='white',&#10;                                          command=self.finish_test, width=20, height=2)&#10;        self.finish_test_button.pack()&#10;&#10;        # Start with first question&#10;        self.display_current_question()&#10;&#10;        # Start the 3-minute countdown timer&#10;        self.start_timer()&#10;&#10;    def start_timer(self):&#10;        &quot;&quot;&quot;Start the 3-minute countdown timer&quot;&quot;&quot;&#10;        self.update_timer()&#10;&#10;    def update_timer(self):&#10;        &quot;&quot;&quot;Update the countdown timer display&quot;&quot;&quot;&#10;        if self.time_remaining &gt; 0:&#10;            minutes = self.time_remaining // 60&#10;            seconds = self.time_remaining % 60&#10;            time_text = f&quot;{minutes:02d}:{seconds:02d}&quot;&#10;&#10;            if self.timer_display:&#10;                self.timer_display.config(text=time_text)&#10;&#10;                # Change color when time is running low&#10;                if self.time_remaining &lt;= 30:  # Last 30 seconds&#10;                    self.timer_display.config(fg='red')&#10;                elif self.time_remaining &lt;= 60:  # Last minute&#10;                    self.timer_display.config(fg='orange')&#10;                else:&#10;                    self.timer_display.config(fg='red')&#10;&#10;            self.time_remaining -= 1&#10;&#10;            # Schedule next update in 1 second&#10;            self.root.after(1000, self.update_timer)&#10;        else:&#10;            # Time's up!&#10;            if self.timer_display:&#10;                self.timer_display.config(text=&quot;00:00&quot;, fg='red')&#10;            self.on_timer_finished()&#10;&#10;    def on_timer_finished(self):&#10;        &quot;&quot;&quot;Handle when the 3-minute timer reaches zero&quot;&quot;&quot;&#10;        print(&quot;Test time finished!&quot;)&#10;        # Save answers and complete the test&#10;        self.save_answers_to_csv()&#10;        if self.completion_callback:&#10;            self.completion_callback(self.answers)&#10;        else:&#10;            # Show time's up message&#10;            self.show_times_up_screen()&#10;&#10;    def show_times_up_screen(self):&#10;        &quot;&quot;&quot;Show the time's up completion screen&quot;&quot;&quot;&#10;        # Clear the root window&#10;        for widget in self.root.winfo_children():&#10;            widget.destroy()&#10;&#10;        completion_frame = tk.Frame(self.root, bg='white')&#10;        completion_frame.pack(fill=tk.BOTH, expand=True)&#10;&#10;        completion_label = tk.Label(&#10;            completion_frame,&#10;            text=&quot;Time's Up!\n\nTest Completed.\nThank you for your participation.&quot;,&#10;            font=(&quot;Arial&quot;, 24, &quot;bold&quot;),&#10;            bg='white',&#10;            fg='black'&#10;        )&#10;        completion_label.pack(expand=True)&#10;&#10;    def display_current_question(self):&#10;        &quot;&quot;&quot;Display the current question&quot;&quot;&quot;&#10;        if self.current_question &lt; len(self.word_data):&#10;            row = self.word_data.iloc[self.current_question]&#10;            icelandic_word = row.get('ice', '')&#10;            self.question_label.config(text=icelandic_word)&#10;&#10;            # Show existing answer&#10;            existing_answer = self.answers.get(self.current_question, '')&#10;            self.answer_entry.delete(0, tk.END)&#10;            self.answer_entry.insert(0, existing_answer)&#10;&#10;            # Update card colors&#10;            self.update_all_cards()&#10;&#10;            # Update button states&#10;            self.prev_button.config(state='normal' if self.current_question &gt; 0 else 'disabled')&#10;            self.next_button.config(state='normal' if self.current_question &lt; self.total_questions - 1 else 'disabled')&#10;&#10;    def update_all_cards(self):&#10;        &quot;&quot;&quot;Update all question card colors based on answer status&quot;&quot;&quot;&#10;        for i in range(len(self.question_cards)):&#10;            card = self.question_cards[i]&#10;            border_frame = self.card_frames[i]&#10;            if i in self.answers and self.answers[i].strip():&#10;                # Answered - green border&#10;                border_frame.config(bg='green')&#10;            else:&#10;                # Unanswered - red border&#10;                border_frame.config(bg='red')&#10;&#10;            # Current question highlight&#10;            if i == self.current_question:&#10;                card.config(bg='lightblue')&#10;            else:&#10;                card.config(bg='white')&#10;&#10;    def on_answer_changed(self, event=None):&#10;        &quot;&quot;&quot;Handle answer change - save on every keystroke&quot;&quot;&quot;&#10;        answer = self.answer_entry.get().strip()&#10;        self.answers[self.current_question] = answer&#10;        self.update_all_cards()&#10;&#10;    def previous_question(self):&#10;        &quot;&quot;&quot;Go to previous question&quot;&quot;&quot;&#10;        if self.current_question &gt; 0:&#10;            self.current_question -= 1&#10;            self.display_current_question()&#10;&#10;    def next_question(self):&#10;        &quot;&quot;&quot;Go to next question&quot;&quot;&quot;&#10;        if self.current_question &lt; self.total_questions - 1:&#10;            self.current_question += 1&#10;            self.display_current_question()&#10;&#10;    def jump_to_question(self, question_index):&#10;        &quot;&quot;&quot;Jump to a specific question when card is clicked&quot;&quot;&quot;&#10;        if 0 &lt;= question_index &lt; self.total_questions:&#10;            self.current_question = question_index&#10;            self.display_current_question()&#10;&#10;    def save_answers_to_csv(self):&#10;        &quot;&quot;&quot;Save the answers to the CSV file in answ_1 column using word_id&quot;&quot;&quot;&#10;        try:&#10;            data_dir = &quot;../data&quot;&#10;            if not os.path.exists(data_dir):&#10;                print(&quot;Data directory not found&quot;)&#10;                return&#10;&#10;            csv_files = [f for f in os.listdir(data_dir)&#10;                        if f.startswith(f&quot;experiment_{self.unique_id}&quot;) and f.endswith('.csv')]&#10;&#10;            if csv_files:&#10;                csv_files.sort()&#10;                latest_csv = os.path.join(data_dir, csv_files[-1])&#10;                df = pd.read_csv(latest_csv)&#10;                &#10;                # Ensure word_id columns are the same type (int)&#10;                df['word_id'] = df['word_id'].astype(int)&#10;&#10;                print(f&quot;Saving {len(self.answers)} answers to CSV...&quot;)&#10;&#10;                # Update the answ_1 column with answers using word_id matching&#10;                for question_index, answer in self.answers.items():&#10;                    if question_index &lt; len(self.word_data):&#10;                        # Get the word_id from the word_data for this question&#10;                        word_id = int(self.word_data.iloc[question_index]['word_id'])&#10;                        &#10;                        # Find the row with matching word_id in the CSV&#10;                        matching_rows = df[df['word_id'] == word_id]&#10;                        if not matching_rows.empty:&#10;                            row_index = matching_rows.index[0]&#10;                            df.loc[row_index, 'answ_1'] = answer&#10;                            print(f&quot;  Saved answer for word_id {word_id}: '{answer}'&quot;)&#10;                        else:&#10;                            print(f&quot;  WARNING: No matching row found for word_id {word_id}&quot;)&#10;&#10;                df.to_csv(latest_csv, index=False)&#10;                print(f&quot;âœ“ First test answers saved to {latest_csv}&quot;)&#10;            else:&#10;                print(&quot;No CSV file found to update&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error saving answers: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def get_answers(self):&#10;        &quot;&quot;&quot;Get the current answers dictionary&quot;&quot;&quot;&#10;        return self.answers.copy()&#10;&#10;    def finish_test(self):&#10;        &quot;&quot;&quot;Finish the test immediately (for testing purposes)&quot;&quot;&quot;&#10;        self.time_remaining = 0&#10;        self.update_timer()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>